<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="amd.20151121225042.1"><vh>@settings</vh>
<v t="amd.20151121225042.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="amd.20151121225042.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="amd.20151121234937.1" a="E"><vh>有關專案</vh>
<v t="amd.20151121234947.1"><vh>OpenShift 與 filezilla</vh></v>
<v t="amd.20151121235037.1"><vh>對應的 OpenShift</vh></v>
<v t="amd.20151122072557.1"><vh>flask socket.io.js 與 OpenShift</vh></v>
<v t="amd.20151122100250.1" a="E"><vh>Brython 繪圖</vh>
<v t="amd.20151122100546.1"><vh>畫五芒星</vh></v>
<v t="amd.20151122100400.1"><vh>台灣國旗</vh></v>
<v t="amd.20151124205805.1"><vh>Gear Utility</vh></v>
</v>
<v t="amd.20151122093651.1"><vh>Pro/Web.Link 程式範例</vh>
<v t="amd.20151122094302.1"><vh>正齒輪繪圖設計參數</vh>
<v t="amd.20151122094302.2"><vh>cube pro/web.link</vh></v>
<v t="amd.20151122094302.3"><vh>四連桿自動組立</vh></v>
</v>
<v t="amd.20151122094542.1"><vh>newHeadline</vh></v>
<v t="amd.20151122094546.1" a="E"><vh>@@clean gear.py</vh>
<v t="amd.20151122094546.2"><vh>&lt;&lt;declarations&gt;&gt; (application)</vh></v>
<v t="amd.20151122094546.3" a="E"><vh>class Gear</vh>
<v t="amd.20151122094546.4"><vh>__init__</vh></v>
<v t="amd.20151122094546.5"><vh>default</vh></v>
<v t="amd.20151122094546.6"><vh>index</vh></v>
<v t="amd.20151122094546.7"><vh>interpolation</vh></v>
<v t="amd.20151122094546.8"><vh>gear_width</vh></v>
<v t="amd.20151122094546.9"><vh>cube_weblink</vh></v>
<v t="amd.20151122094546.10"><vh>gear_weblink</vh></v>
</v>
</v>
<v t="amd.20151122094835.1"><vh>@@clean wsgi.py</vh>
<v t="amd.20151122094835.2"><vh>&lt;&lt;declarations&gt;&gt; (wsgi)</vh></v>
<v t="amd.20151122094835.3"><vh>sizeof_fmt</vh></v>
<v t="amd.20151122094835.4"><vh>class Brython</vh>
<v t="amd.20151122094835.5"><vh>__init__</vh></v>
<v t="amd.20151122094835.6"><vh>index</vh></v>
<v t="amd.20151122094835.7"><vh>spur</vh></v>
<v t="amd.20151122094835.8"><vh>spuraction</vh></v>
<v t="amd.20151122094835.9"><vh>drawspur</vh></v>
<v t="amd.20151122094835.10"><vh>drawspuraction</vh></v>
<v t="amd.20151122094835.11"><vh>cube</vh></v>
<v t="amd.20151122094835.12"><vh>cubeaction</vh></v>
<v t="amd.20151122094835.13"><vh>fileuploadform</vh></v>
<v t="amd.20151122094835.14"><vh>fileaxupload</vh></v>
<v t="amd.20151122094835.15"><vh>download_list</vh></v>
<v t="amd.20151122094835.16"><vh>threegears</vh></v>
</v>
<v t="amd.20151122094835.17"><vh>class Download</vh>
<v t="amd.20151122094835.18"><vh>index</vh></v>
</v>
</v>
<v t="amd.20151122094920.1"><vh>@@edit Brython_spur.py</vh></v>
<v t="amd.20151122095255.1"><vh>樂高人偶組立 man1</vh></v>
<v t="amd.20151122095546.1"><vh>樂高人偶組立 man2</vh></v>
</v>
<v t="amd.20151122095724.1"><vh>STL 零件檔轉換</vh>
<v t="amd.20151122095840.1"><vh>建立 Binary STL</vh></v>
</v>
<v t="amd.20151122102956.1"><vh>網際機構模擬</vh></v>
<v t="amd.20151122214658.1"><vh>Gitlab on Ubuntu</vh></v>
</v>
<v t="amd.20151122075148.1"><vh>建立資料庫指令</vh></v>
<v t="amd.20151122075205.1"><vh>@edit schema.sql</vh></v>
<v t="amd.20151122075220.1"><vh>@button create db</vh></v>
<v t="amd.20151121233734.1"><vh>@edit README.md</vh></v>
<v t="amd.20151121233918.1"><vh>@edit setup.py</vh></v>
<v t="amd.20151122065955.1"><vh>@edit wsgi.py</vh></v>
<v t="amd.20151122075104.1"><vh>@edit pybean.py</vh></v>
<v t="amd.20151121225024.2" a="E"><vh>@clean guess.py</vh>
<v t="amd.20151121225723.1"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="amd.20151121225321.1"><vh>index</vh></v>
<v t="amd.20151121225340.1"><vh>guessform</vh></v>
<v t="amd.20151121225334.1"><vh>docheck</vh></v>
<v t="amd.20151124172242.1"><vh>drawflag</vh></v>
<v t="amd.20151124205123.1"><vh>drawstar</vh></v>
<v t="amd.20151124210158.1"><vh>drawcango</vh></v>
<v t="amd.20151124215720.1"><vh>drag</vh></v>
</v>
<v t="amd.20151122075345.1"><vh>@clean gear.py</vh>
<v t="amd.20151122075345.2"><vh>&lt;&lt;declarations&gt;&gt; (application)</vh></v>
<v t="amd.20151122075345.3"><vh>class Gear</vh>
<v t="amd.20151122075345.4"><vh>__init__</vh></v>
<v t="amd.20151122075345.6"><vh>index</vh></v>
<v t="amd.20151122075345.7"><vh>interpolation</vh></v>
<v t="amd.20151122075345.8"><vh>gear_width</vh></v>
</v>
</v>
<v t="amd.20151121225346.1"><vh>@path templates</vh>
<v t="amd.20151121225407.1"><vh>@edit index.html</vh></v>
<v t="amd.20151121225415.1"><vh>@edit guessform.html</vh></v>
<v t="amd.20151121225445.1"><vh>@edit docheck.html</vh></v>
<v t="amd.20151121230507.1"><vh>@edit toobig.html</vh></v>
<v t="amd.20151121230514.1"><vh>@edit toosmall.html</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="amd.20151121225024.2">@language python
# 以下為宣告 ################################## (1)
&lt;&lt; declarations &gt;&gt;

# 以下為全域變數宣告 ############################# (2)
# 確定程式檔案所在目錄, 在 Windows 有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))

# 設定在雲端與近端的資料儲存目錄
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示程式在雲端執行
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
    template_root_dir = os.environ['OPENSHIFT_REPO_DIR']+"/static"
else:
    # 表示程式在近端執行
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"
    template_root_dir = _curdir + "/static"

# 啟動 app
app = Flask(__name__)

# 使用 session 必須要設定 secret_key
app.secret_key = 'A0Zr9@8j/3yX R~XHH!jmN]LWX/,?R@T'

# 以下為相關各方法的定義 ########################### (3)
@others


</t>
<t tx="amd.20151121225042.1"></t>
<t tx="amd.20151121225042.2">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="amd.20151121225042.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="amd.20151121225321.1">@app.route("/")
def index():
    #這是猜數字遊戲的起始表單, 主要在產生答案, 並且將 count 歸零
    # 將標準答案存入 answer session 對應區
    theanswer = random.randint(1, 100)
    thecount = 0
    # 將答案與計算次數變數存進 session 對應變數
    session['answer'] = theanswer
    session['count'] = thecount

    return render_template("index.html", answer=theanswer, count=thecount)</t>
<t tx="amd.20151121225334.1">@app.route('/docheck', methods=['POST'])
def docheck():
    # session[] 存資料
    # session.get() 取 session 資料
    # 利用 request.form[] 取得表單欄位資料, 然後送到 template
    guess = request.form["guess"]
    session["guess"] = guess
    # 假如使用者直接執行 doCheck, 則設法轉回根方法
    if guess is None:
        redirect("/")
    # 從 session 取出 answer 對應資料, 且處理直接執行 docheck 時無法取 session 值情況
    try:
        theanswer = int(session.get('answer'))
    except:
        redirect("/")
    # 經由表單所取得的 guess 資料型別為 string
    try:
        theguess = int(guess)
    except:
        return redirect("/guessform")
    # 每執行 doCheck 一次,次數增量一次
    session["count"] += 1
    count = session.get("count")
    # 答案與所猜數字進行比對
    if theanswer &lt; theguess:
        return render_template("toobig.html", guess=guess, answer=theanswer, count=count)
    elif theanswer &gt; theguess:
        return render_template("toosmall.html", guess=guess, answer=theanswer, count=count)
    else:
        # 已經猜對, 從 session 取出累計猜測次數
        thecount = session.get('count')
        return "猜了 "+str(thecount)+" 次, 終於猜對了, 正確答案為 "+str(theanswer)+": &lt;a href='/'&gt;再猜&lt;/a&gt;"
    # 應該不會執行下列一行
    return render_template("docheck.html", guess=guess)</t>
<t tx="amd.20151121225340.1">@app.route('/guessform')
def guessform():
    session["count"] += 1
    guess = session.get("guess")
    theanswer = session.get("answer")
    count = session.get("count")
    
    return render_template("guessform.html", guess=guess, answer=theanswer, count=count)</t>
<t tx="amd.20151121225346.1"></t>
<t tx="amd.20151121225723.1"># 導入 os 模組, 主要用來判斷是否在 OpenShift 上執行
import os
from flask import Flask, request, redirect, render_template, session
import random
</t>
<t tx="amd.20151121234937.1">程式語言二 (2014 Spring C2): http://2014c2-mdenfu.rhcloud.com/

2015CD: http://cd-cadp.rhcloud.com/

往年課程網頁:

http://blog.kmol.info/indexd65e.html?cat=8

http://wiki.mde.tw

2014 Fall 計算機程式:

http://cp.kmol.info

http://2014cp.kmol.info

2014 Fall 電腦助設計實習:

http://2014-cadp.rhcloud.com/

http://cadp.kmol.info

http://2014cadp.kmol.info</t>
<t tx="amd.20151121234947.1">ssh-add ~/.ssh/id_rsa</t>
<t tx="amd.20151121235037.1">ssh://56508f8689f5cf0897000188@cptocadp-2015fallhw.rhcloud.com/~/git/cptocadp.git/</t>
<t tx="amd.20151122072557.1">http://vene.ro/blog/flask-socketio-openshift-fallback-xhr-polling.html</t>
<t tx="amd.20151122075148.1">sqlite3 local_data/db/database.db &lt; schema.sql</t>
<t tx="amd.20151122075220.1">@language python
'''
local_data/db/database.db
'''
import os

os.system("sqlite3 local_data/db/database.db &lt; schema.sql")
# echo string
'''
for Leo Editor:
c is the commander of the outline containing the script.
g is Leo’s leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
g.es("database.db created")</t>
<t tx="amd.20151122075345.1">@language python
@tabwidth -4
&lt;&lt;declarations&gt;&gt;
@others


</t>
<t tx="amd.20151122075345.2">@language python

from flask import Flask, request, redirect, render_template, session
import os
import sys
# 這個程式要計算正齒輪的齒面寬, 資料庫連結希望使用 pybean 與 SQLite
# 導入 pybean 模組與所要使用的 Store 及 SQLiteWriter 方法
from pybean import Store, SQLiteWriter
import math

# 確定程式檔案所在目錄, 在 Windows 有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))
# 將所在目錄設為系統搜尋目錄
sys.path.append(_curdir)
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # while program is executed in OpenShift
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
else:
    # while program is executed in localhost
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"

# 這是 Gear 設計資料表的定義
'''

lewis.db 中有兩個資料表, steel 與 lewis

 CREATE TABLE steel ( 
    serialno      INTEGER,
    unsno         TEXT,
    aisino        TEXT,
    treatment     TEXT,
    yield_str     INTEGER,
    tensile_str   INTEGER,
    stretch_ratio INTEGER,
    sectional_shr INTEGER,
    brinell       INTEGER 
);

CREATE TABLE lewis ( 
    serialno INTEGER PRIMARY KEY
                     NOT NULL,
    gearno   INTEGER,
    type1    NUMERIC,
    type4    NUMERIC,
    type3    NUMERIC,
    type2    NUMERIC 
);
'''

</t>
<t tx="amd.20151122075345.3">class Gear(object):
    @others
</t>
<t tx="amd.20151122075345.4">def __init__(self):
    # hope to create downloads and images directories　
    if not os.path.isdir(download_root_dir+"downloads"):
        try:
            os.makedirs(download_root_dir+"downloads")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"images"):
        try:
            os.makedirs(download_root_dir+"images")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"tmp"):
        try:
            os.makedirs(download_root_dir+"tmp")
        except:
            print("mkdir error")
</t>
<t tx="amd.20151122075345.6"># 各組利用 index 引導隨後的程式執行
#@app.route("/gear_index")
def index(self, *args, **kwargs):
    # 進行資料庫檔案連結,  並且取出所有資料
    try:
        # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
        # 因為程式以 application 所在目錄執行, 因此利用相對目錄連結 lewis.db 資料庫檔案
        SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
        #material = SQLite連結.find_one("steel","serialno = ?",[序號])
        # str(SQLite連結.count("steel")) 將傳回 70, 表示資料庫中有 70 筆資料
        material = SQLite連結.find("steel")
        # 所傳回的 material 為 iterator
        '''
        outstring = ""
        for material_item in material:
            outstring += str(material_item.serialno) + ":" + material_item.unsno + "_" + material_item.treatment + "&lt;br /&gt;"
        return outstring
        '''
    except:
        return "抱歉! 資料庫無法連線&lt;br /&gt;"

    outstring = '''
&lt;form id=entry method=post action="/gear_width"&gt;
請填妥下列參數，以完成適當的齒尺寸大小設計。&lt;br /&gt;
馬達馬力:&lt;input type=text name=horsepower id=horsepower value=100 size=10&gt;horse power&lt;br /&gt;
馬達轉速:&lt;input type=text name=rpm id=rpm value=1120 size=10&gt;rpm&lt;br /&gt;
齒輪減速比: &lt;input type=text name=ratio id=ratio value=4 size=10&gt;&lt;br /&gt;
齒形:&lt;select name=toothtype id=toothtype&gt;
&lt;option value=type1&gt;壓力角20度,a=0.8,b=1.0
&lt;option value=type2&gt;壓力角20度,a=1.0,b=1.25
&lt;option value=type3&gt;壓力角25度,a=1.0,b=1.25
&lt;option value=type4&gt;壓力角25度,a=1.0,b=1.35
&lt;/select&gt;&lt;br /&gt;
安全係數:&lt;input type=text name=safetyfactor id=safetyfactor value=3 size=10&gt;&lt;br /&gt;
齒輪材質:&lt;select name=material_serialno id=material_serialno&gt;
'''
    for material_item in material:
        outstring += "&lt;option value=" + str(material_item.serialno) + "&gt;UNS - " + \
            material_item.unsno + " - " + material_item.treatment
    outstring += "&lt;/select&gt;&lt;br /&gt;"
    
    outstring += "小齒輪齒數:&lt;input type=text name=npinion id=npinion value=18 size=10&gt;&lt;br /&gt;"
    outstring += "&lt;input type=submit id=submit value=進行運算&gt;"
    outstring += "&lt;/form&gt;"

    return outstring
</t>
<t tx="amd.20151122075345.7">#@app.route("/interpoloation")
def interpolation(self, small_gear_no=18, gear_type=1):
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    # 使用內插法求值
    # 找出比目標齒數大的其中的最小的,就是最鄰近的大值
    lewis_factor = SQLite連結.find_one("lewis","gearno &gt; ?",[small_gear_no])
    if(gear_type == 1):
        larger_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        larger_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        larger_formfactor = lewis_factor.type3
    else:
        larger_formfactor = lewis_factor.type4
    larger_toothnumber = lewis_factor.gearno
 
    # 找出比目標齒數小的其中的最大的,就是最鄰近的小值
    lewis_factor = SQLite連結.find_one("lewis","gearno &lt; ? order by gearno DESC",[small_gear_no])
    if(gear_type == 1):
        smaller_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        smaller_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        smaller_formfactor = lewis_factor.type3
    else:
        smaller_formfactor = lewis_factor.type4
    smaller_toothnumber = lewis_factor.gearno
    calculated_factor = larger_formfactor + (small_gear_no - larger_toothnumber) * (larger_formfactor - smaller_formfactor) / (larger_toothnumber - smaller_toothnumber)
    # 只傳回小數點後五位數
    return str(round(calculated_factor, 5))
</t>
<t tx="amd.20151122075345.8"># 改寫為齒面寬的設計函式
#@app.route("/gear_width")
#def gear_width(self, horsepower=100, rpm=1000, ratio=4, toothtype=1, safetyfactor=2, material_serialno=1, npinion=18):
def gear_width(self):
    horsepower = request.form["horsepower"]
    rpm = request.form["rpm"]
    ratio = request.form["ratio"]
    toothtype = request.form["toothtype"]
    safetyfactor = request.form["safetyfactor"]
    material_serialno = request.form["material_serialno"]
    npinion= request.form["npinion"]
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    outstring = ""
    # 根據所選用的齒形決定壓力角
    if(toothtype == 1 or toothtype == 2):
        壓力角 = 20
    else:
        壓力角 = 25
 
    # 根據壓力角決定最小齒數
    if(壓力角== 20):
        最小齒數 = 18
    else:
        最小齒數 = 12
 
    # 直接設最小齒數
    if int(npinion) &lt;= 最小齒數:
        npinion = 最小齒數
    # 大於400的齒數則視為齒條(Rack)
    if int(npinion) &gt;= 400:
        npinion = 400
 
    # 根據所選用的材料查詢強度值
    # 由 material之序號查 steel 表以得材料之降伏強度S單位為 kpsi 因此查得的值要成乘上1000
    # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
    #SQLite連結 = Store(SQLiteWriter("lewis.db", frozen=True))
    # 指定 steel 資料表
    steel = SQLite連結.new("steel")
    # 資料查詢
    #material = SQLite連結.find_one("steel","unsno=? and treatment=?",[unsno, treatment])
    material = SQLite連結.find_one("steel","serialno=?",[material_serialno])
    # 列出 steel 資料表中的資料筆數
    #print(SQLite連結.count("steel"))
    #print (material.yield_str)
    strengthstress = material.yield_str*1000
    # 由小齒輪的齒數與齒形類別,查詢lewis form factor
    # 先查驗是否有直接對應值
    on_table = SQLite連結.count("lewis","gearno=?",[npinion])
    if on_table == 1:
        # 直接進入設計運算
        #print("直接運算")
        #print(on_table)
        lewis_factor = SQLite連結.find_one("lewis","gearno=?",[npinion])
        #print(lewis_factor.type1)
        # 根據齒形查出 formfactor 值
        if(toothtype == 1):
            formfactor = lewis_factor.type1
        elif(toothtype == 2):
            formfactor = lewis_factor.type2
        elif(toothtype == 3):
            formfactor = lewis_factor.type3
        else:
            formfactor = lewis_factor.type4
    else:
        # 沒有直接對應值, 必須進行查表內插運算後, 再執行設計運算
        #print("必須內插")
        #print(interpolation(npinion, gear_type))
        formfactor = self.interpolation(npinion, toothtype)
 
    # 開始進行設計運算
 
    ngear = int(npinion) * int(ratio)
 
    # 重要的最佳化設計---儘量用整數的diametralpitch
    # 先嘗試用整數算若 diametralpitch 找到100 仍無所獲則改用 0.25 作為增量再不行則宣告 fail
    counter = 0
    i = 0.1
    facewidth = 0
    circularpitch = 0
    while (facewidth &lt;= 3 * circularpitch or facewidth &gt;= 5 * circularpitch):
        diametralpitch = i
        #circularpitch = 3.14159/diametralpitch
        circularpitch = math.pi/diametralpitch
        pitchdiameter = int(npinion)/diametralpitch
        #pitchlinevelocity = 3.14159*pitchdiameter*rpm/12
        pitchlinevelocity = math.pi*pitchdiameter * float(rpm)/12
        transmittedload = 33000*float(horsepower)/pitchlinevelocity
        velocityfactor = 1200/(1200 + pitchlinevelocity)
        # formfactor is Lewis form factor
        # formfactor need to get from table 13-3 and determined ty teeth number and type of tooth
        # formfactor = 0.293
        # 90 is the value get from table corresponding to material type
        facewidth = transmittedload*diametralpitch*float(safetyfactor)/velocityfactor/formfactor/strengthstress
        if(counter&gt;5000):
            outstring += "超過5000次的設計運算,仍無法找到答案!&lt;br /&gt;"
            outstring += "可能所選用的傳遞功率過大,或無足夠強度的材料可以使用!&lt;br /&gt;"
            # 離開while迴圈
            break
        i += 0.1
        counter += 1
    facewidth = round(facewidth, 4)
    if(counter&lt;5000):
        outstring = "進行"+str(counter)+"次重複運算後,得到合用的facewidth值為:"+str(facewidth)
    return outstring
</t>
<t tx="amd.20151122093651.1">Creo Pro/Web.Link

零件尺寸控制

零件自動組立

全球資訊網的 E2E 協同設計流程:

設計者完成參數化零件繪圖
設計者根據所設想的設計標的, 完成參數化零件組立
設計者提供一個全球資訊網輔助設計程式表單, 讓使用者自行輸入所需要的設計標的
系統根據使用者所輸入的設計參數進行演算, 得到符合設計需求的各零組件尺寸
系統根據演算所得各零件的尺寸, 以參數化變更各零件尺寸後在使用者端存檔
系統啟動自動組立程式, 以演算所得的零件進行自動組立
使用者檢視系統所完成的設計結果, 決定下一步動作

2014cadp 網際程式結合 Pro/Web.Link 齒輪尺寸變更: https://copy.com/lPRwb2vGYMyfRncX</t>
<t tx="amd.20151122094302.1">dp=1/module
wholedepth=2.25*module

ADDENDUM = 1/dp
clearance = wholedepth-(2*ADDENDUM)
DEDENDUM = wholedepth-ADDENDUM-clearance

D147 = clearance
invpressangle=tan(pressangle)-(pressangle/180)*pi
PITCHDIA = n/dp
ROOT_DIA=PITCHDIA-(2*DEDENDUM)-(2*clearance)
THK_P = (pi/2)/dp
TANGP=(2*THK_P/PITCHDIA)*180/PI
toverd=THK_P/PITCHDIA
ADDENDUMDIA=PITCHDIA+(2*ADDENDUM)
PITCHDIAMETER = PITCHDIA
BASEDIA = pitchdia*cos(pressangle)
BASEDIAMETER = BASEDIA
z=invpressangle+toverd
THK_B = (z)*BASEDIA
TANGBASE=(2*THK_B/BASEDIA)*180/PI
pd = n/dp
a = pressangle
ad = ADDENDUM
D_O = pd+(2*(ad))
r_b = .5*pd*cos(pressangle)
D320 = tangbase/2
D325 = tangbase/2
D335 = 360/n
P337=n-1
D336 = 360/N
D327 = face_width
D334 = face_width

D566 = .39/dp
D686 = BORE_DIA

D722 = (PITCHDIAMETER+(2*ADDENDUM))/2
D720 = .8*ADDENDUM
/*D748 = .4*d739
/*D747 = .4*d739</t>
<t tx="amd.20151122094302.2">&lt;h1&gt;Creo 參數化零件&lt;/h1&gt;
&lt;script type="text/javascript" src="/static/weblink/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/weblink/wl_header.js"&gt;// &lt;![CDATA[
document.writeln ("Error loading Pro/Web.Link header!");
// ]]&gt;&lt;/script&gt;
&lt;script type="text/javascript" language="JavaScript"&gt;// &lt;![CDATA[
if (!pfcIsWindows()) netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// 若第三輸入為 false, 表示僅載入 session, 但是不顯示
// ret 為 model open return
 var ret = document.pwl.pwlMdlOpen("cube.prt", "v:/tmp", false);
if (!ret.Status) {
    alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
}
    //將 ProE 執行階段設為變數 session
    var session = pfcGetProESession();
    // 在視窗中打開零件檔案, 並且顯示出來
    var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("cube.prt"));
    var solid = session.GetModel("cube.prt",pfcCreate("pfcModelType").MDL_PART);
    var length,width,myf,myn,i,j,volume,count,d1Value,d2Value;
    // 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("a1");
    // 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("a2");
//改變零件尺寸
    //myf=20;
    //myn=20;
    volume=0;
    count=0;
    try
    {
            // 以下採用 URL 輸入對應變數
            //createParametersFromArguments ();
            // 以下則直接利用 javascript 程式改變零件參數
            for(i=0;i&lt;=5;i++)
            {
                //for(j=0;j&lt;=2;j++)
                //{
                    myf=100.0;
                    myn=100.0+i*5.0;
// 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
         d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
         d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);
// 將處理好的變數值, 指定給對應的零件變數
                    length.Value = d1Value;
                    width.Value = d2Value;
                    //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
                    solid.Regenerate(void null);
                    //利用 GetMassProperty 取得模型的質量相關物件
                    properties = solid.GetMassProperty(void null);
                    //volume = volume + properties.Volume;
volume = properties.Volume;
                    count = count + 1;
alert("執行第"+count+"次,零件總體積:"+volume);
// 將零件存為新檔案
var newfile = document.pwl.pwlMdlSaveAs("cube.prt", "v:/tmp", "cube"+count+".prt");
if (!newfile.Status) {
    alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
}
//} // 內圈 for 迴圈
            } //外圈 for 迴圈
            //alert("共執行:"+count+"次,零件總體積:"+volume);
            //alert("零件體積:"+properties.Volume);
            //alert("零件體積取整數:"+Math.round(properties.Volume));
        }
    catch(err)
        {
            alert ("Exception occurred: "+pfcGetExceptionType (err));
        }
// ]]&gt;&lt;/script&gt;</t>
<t tx="amd.20151122094302.3">&lt;script type="text/javascript" src="/static/weblink/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/weblink/wl_header.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;// &lt;![CDATA[
if (!pfcIsWindows())
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
var session = pfcGetProESession();
// 設定 config option
session.SetConfigOption("comp_placement_assumptions","no");
// 建立擺放零件的位置矩陣
var identityMatrix = pfcCreate ("pfcMatrix3D");
for (var x = 0; x &lt; 4; x++)
	for (var y = 0; y &lt; 4; y++)
	{
		if (x == y)
			identityMatrix.Set (x, y, 1.0);
		else
			identityMatrix.Set (x, y, 0.0);
	}
var transf = pfcCreate ("pfcTransform3D").Create (identityMatrix);
// 取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
// 以目前已開檔, 作為 model
var model = session.CurrentModel;
// 查驗有無 model, 或 model 類別是否為組立件
if (model == void null || model.Type != pfcCreate ("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
var assembly = model;
/**----------------------------------------------- link0 -------------------------------------------------------------**/
    //檔案目錄，建議將圖檔放置工作目錄下較方便使用
	var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link0.prt");
	// 若 link1.prt 在 session 則直接取用
	var componentModel = session.GetModelFromDescr (descr);
	//若 link1.prt 不在 session 則從工作目錄中載入 session
	var componentModel = session.RetrieveModel(descr);
	//若 link1.prt 已經在 session 則放入組立檔中
	if (componentModel != void null)
	{
		//注意這個 asmcomp 即為設定約束條件的本體
		//asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
		var asmcomp = assembly.AssembleComponent (componentModel, transf);
	}
// 建立約束條件變數
var constrs = pfcCreate ("pfcComponentConstraints");
//設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT
var asmDatums = new Array ("ASM_FRONT", "ASM_TOP", "ASM_RIGHT");
//設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
var compDatums = new Array ("FRONT", "TOP", "RIGHT");
	//建立 ids 變數, intseq 為 sequence of integers 為資料類別, 使用者可以經由整數索引擷取此資料類別的元件, 第一個索引為 0
	var ids = pfcCreate ("intseq");
	//建立路徑變數
	var path = pfcCreate ("MpfcAssembly").CreateComponentPath (assembly, ids);
	//採用互動式設定相關的變數
	var MpfcSelect = pfcCreate ("MpfcSelect");
//利用迴圈分別約束組立與零件檔中的三個定位平面
for (var i = 0; i &lt; 3; i++)
{
	//設定組立參考面
	var asmItem = assembly.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, asmDatums [i]);
	//若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
	if (asmItem == void null)
	{
		interactFlag = true;
		continue;
	}
	//設定零件參考面
	var compItem = componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, compDatums [i]);
	//若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
	if (compItem == void null)
	{
		interactFlag = true;
		continue;
	}
	var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, path);
	var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
	var constr = pfcCreate ("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
	constr.AssemblyReference = asmSel;
	constr.ComponentReference = compSel;
	constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (false, false);
	//將互動選擇相關資料, 附加在程式約束變數之後
	constrs.Append (constr);
}
//設定組立約束條件
asmcomp.SetConstraints (constrs, void null);
/**-------------------------------------------------------------------------------------------------------------------**/
/**----------------------------------------------- link1 -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link1.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
	var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
var featID = components.Item(0).Id;
ids.Append(featID);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_1", "TOP", "ASM_TOP");
var compDatums = new Array ("A_1", "TOP", "TOP");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
	
/**-------------------------------------------------------------------------------------------------------------------**/
/**----------------------------------------------- link2 -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link2.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
	var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate ("intseq");
ids.Append(featID+1);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2", "TOP", "ASM_TOP");
var compDatums = new Array ("A_1", "TOP", "TOP");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
	
/**-------------------------------------------------------------------------------------------------------------------**/
/**----------------------------------------------- link3 -------------------------------------------------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/fourbar/link3.prt");
var componentModel = session.GetModelFromDescr (descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
	var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate ("pfcComponentConstraints");
var ids = pfcCreate ("intseq");
ids.Append(featID+2);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2");
var compDatums = new Array ("A_1");
for (var i = 0; i &lt; 1; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
var ids = pfcCreate ("intseq");
ids.Append(featID);
var subPath = pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
subassembly = subPath.Leaf;
var asmDatums = new Array ("A_2", "TOP");
var compDatums = new Array ("A_2", "BOTTON");
for (var i = 0; i &lt; 2; i++)
	{
		var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
		if (asmItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
		if (compItem == void null)
		{
			interactFlag = true;
			continue;
		}
		var MpfcSelect = pfcCreate ("MpfcSelect");
		var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
		var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
		var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
		constr.AssemblyReference  = asmSel;
		constr.ComponentReference = compSel;
		constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, true);
		constrs.Append (constr);
	}
asmcomp.SetConstraints (constrs, void null);
/**-------------------------------------------------------------------------------------------------------------------**/
var session = pfcGetProESession ();
var solid = session.CurrentModel;
properties = solid.GetMassProperty(void null);
var COG = properties.GravityCenter;
document.write("MassProperty:&lt;br /&gt;");
document.write("Mass:"+(properties.Mass.toFixed(2))+"       pound&lt;br /&gt;");
document.write("Average Density:"+(properties.Density.toFixed(2))+"       pound/inch^3&lt;br /&gt;");
document.write("Surface area:"+(properties.SurfaceArea.toFixed(2))+"           inch^2&lt;br /&gt;");
document.write("Volume:"+(properties.Volume.toFixed(2))+"   inch^3&lt;br /&gt;");
document.write("COG_X:"+COG.Item(0).toFixed(2)+"&lt;br /&gt;");
document.write("COG_Y:"+COG.Item(1).toFixed(2)+"&lt;br /&gt;");
document.write("COG_Z:"+COG.Item(2).toFixed(2)+"&lt;br /&gt;");
try
{
document.write("Current Directory:&lt;br /&gt;"+currentDir);
}
catch (err)
{
alert ("Exception occurred: "+pfcGetExceptionType (err));
}
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();
// ]]&gt;&lt;/script&gt;</t>
<t tx="amd.20151122094542.1"></t>
<t tx="amd.20151122094546.1">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
root = Gear()

# setup static, images and downloads directories
application_conf = {
        '/static':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': _curdir+"/static"},
        '/images':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/images"},
        '/downloads':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/downloads"}
    }

# if inOpenshift ('OPENSHIFT_REPO_DIR' exists in environment variables) or not inOpenshift
if __name__ == '__main__':
    if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
        # operate in OpenShift
        application = cherrypy.Application(root, config = application_conf)
    else:
        # operate in localhost
        cherrypy.quickstart(root, config = application_conf)

</t>
<t tx="amd.20151122094546.10">@cherrypy.expose
def gear_weblink(self, facewidth=5, n=18):
    outstring = '''&lt;script type="text/javascript" src="/static/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/wl_header.js"&gt;// &lt;![CDATA[
document.writeln ("Error loading Pro/Web.Link header!");
// ]]&gt;&lt;/script&gt;
&lt;script type="text/javascript" language="JavaScript"&gt;// &lt;![CDATA[
if (!pfcIsWindows()) netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// 若第三輸入為 false, 表示僅載入 session, 但是不顯示
// ret 為 model open return
 var ret = document.pwl.pwlMdlOpen("gear.prt", "v:/", false);
if (!ret.Status) {
    alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
}
    //將 ProE 執行階段設為變數 session
    var session = pfcGetProESession();
    // 在視窗中打開零件檔案, 並且顯示出來
    var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("gear.prt"));
    var solid = session.GetModel("gear.prt",pfcCreate("pfcModelType").MDL_PART);
    var length,width,myf,myn,i,j,volume,count,d1Value,d2Value;
    // 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("n");
    // 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("face_width");
//改變零件尺寸
    //myf=20;
    //myn=20;
    volume=0;
    count=0;
    try
    {
            // 以下採用 URL 輸入對應變數
            //createParametersFromArguments ();
            // 以下則直接利用 javascript 程式改變零件參數
            for(i=0;i&lt;=5;i++)
            {
                //for(j=0;j&lt;=2;j++)
                //{
                    myf=25+i*2;
                    myn=10.0+i*0.5;
// 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
         //d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
         d1Value = pfcCreate ("MpfcModelItem").CreateIntParamValue(myf);
         d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);

// 將處理好的變數值, 指定給對應的零件變數
                    length.Value = d1Value;
                    width.Value = d2Value;
                    //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
                    solid.Regenerate(void null);
                    //利用 GetMassProperty 取得模型的質量相關物件
                    properties = solid.GetMassProperty(void null);
                    //volume = volume + properties.Volume;
volume = properties.Volume;
                    count = count + 1;
alert("執行第"+count+"次,零件總體積:"+volume);
// 將零件存為新檔案
var newfile = document.pwl.pwlMdlSaveAs("gear.prt", "v:/", "mygear_"+count+".prt");
if (!newfile.Status) {
    alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
}
//} // 內圈 for 迴圈
            } //外圈 for 迴圈
            //alert("共執行:"+count+"次,零件總體積:"+volume);
            //alert("零件體積:"+properties.Volume);
            //alert("零件體積取整數:"+Math.round(properties.Volume));
        }
    catch(err)
        {
            alert ("Exception occurred: "+pfcGetExceptionType (err));
        }
// ]]&gt;&lt;/script&gt;
'''
    return outstring
</t>
<t tx="amd.20151122094546.2">@language python

import cherrypy
import os
import sys
# 這個程式要計算正齒輪的齒面寬, 資料庫連結希望使用 pybean 與 SQLite
# 導入 pybean 模組與所要使用的 Store 及 SQLiteWriter 方法
from pybean import Store, SQLiteWriter
import math

# 確定程式檔案所在目錄, 在 Windows 有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))
# 將所在目錄設為系統搜尋目錄
sys.path.append(_curdir)
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # while program is executed in OpenShift
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
else:
    # while program is executed in localhost
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"

# 這是 Gear 設計資料表的定義
'''

lewis.db 中有兩個資料表, steel 與 lewis

 CREATE TABLE steel ( 
    serialno      INTEGER,
    unsno         TEXT,
    aisino        TEXT,
    treatment     TEXT,
    yield_str     INTEGER,
    tensile_str   INTEGER,
    stretch_ratio INTEGER,
    sectional_shr INTEGER,
    brinell       INTEGER 
);

CREATE TABLE lewis ( 
    serialno INTEGER PRIMARY KEY
                     NOT NULL,
    gearno   INTEGER,
    type1    NUMERIC,
    type4    NUMERIC,
    type3    NUMERIC,
    type2    NUMERIC 
);
'''

</t>
<t tx="amd.20151122094546.3">class Gear(object):
    @others
</t>
<t tx="amd.20151122094546.4">def __init__(self):
    # hope to create downloads and images directories　
    if not os.path.isdir(download_root_dir+"downloads"):
        try:
            os.makedirs(download_root_dir+"downloads")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"images"):
        try:
            os.makedirs(download_root_dir+"images")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"tmp"):
        try:
            os.makedirs(download_root_dir+"tmp")
        except:
            print("mkdir error")
</t>
<t tx="amd.20151122094546.5">@cherrypy.expose
def default(self, attr='default', *args, **kwargs):
    raise cherrypy.HTTPRedirect("/")
</t>
<t tx="amd.20151122094546.6"># 各組利用 index 引導隨後的程式執行
@cherrypy.expose
def index(self, *args, **kwargs):
    # 進行資料庫檔案連結,  並且取出所有資料
    try:
        # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
        # 因為程式以 application 所在目錄執行, 因此利用相對目錄連結 lewis.db 資料庫檔案
        SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
        #material = SQLite連結.find_one("steel","serialno = ?",[序號])
        # str(SQLite連結.count("steel")) 將傳回 70, 表示資料庫中有 70 筆資料
        material = SQLite連結.find("steel")
        # 所傳回的 material 為 iterator
        '''
        outstring = ""
        for material_item in material:
            outstring += str(material_item.serialno) + ":" + material_item.unsno + "_" + material_item.treatment + "&lt;br /&gt;"
        return outstring
        '''
    except:
        return "抱歉! 資料庫無法連線&lt;br /&gt;"

    outstring = '''
\\-4.&lt;form id=entry method=post action="gear_width"&gt;
\\-4.請填妥下列參數，以完成適當的齒尺寸大小設計。&lt;br /&gt;
\\-4.馬達馬力:&lt;input type=text name=horsepower id=horsepower value=100 size=10&gt;horse power&lt;br /&gt;
\\-4.馬達轉速:&lt;input type=text name=rpm id=rpm value=1120 size=10&gt;rpm&lt;br /&gt;
\\-4.齒輪減速比: &lt;input type=text name=ratio id=ratio value=4 size=10&gt;&lt;br /&gt;
\\-4.齒形:&lt;select name=toothtype id=toothtype&gt;
\\-4.&lt;option value=type1&gt;壓力角20度,a=0.8,b=1.0
\\-4.&lt;option value=type2&gt;壓力角20度,a=1.0,b=1.25
\\-4.&lt;option value=type3&gt;壓力角25度,a=1.0,b=1.25
\\-4.&lt;option value=type4&gt;壓力角25度,a=1.0,b=1.35
\\-4.&lt;/select&gt;&lt;br /&gt;
\\-4.安全係數:&lt;input type=text name=safetyfactor id=safetyfactor value=3 size=10&gt;&lt;br /&gt;
\\-4.齒輪材質:&lt;select name=material_serialno id=material_serialno&gt;
\\-4.'''
    for material_item in material:
        outstring += "&lt;option value=" + str(material_item.serialno) + "&gt;UNS - " + \
            material_item.unsno + " - " + material_item.treatment
    outstring += "&lt;/select&gt;&lt;br /&gt;"
    
    outstring += "小齒輪齒數:&lt;input type=text name=npinion id=npinion value=18 size=10&gt;&lt;br /&gt;"
    outstring += "&lt;input type=submit id=submit value=進行運算&gt;"
    outstring += "&lt;/form&gt;"

    return outstring
</t>
<t tx="amd.20151122094546.7">@cherrypy.expose
def interpolation(self, small_gear_no=18, gear_type=1):
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    # 使用內插法求值
    # 找出比目標齒數大的其中的最小的,就是最鄰近的大值
    lewis_factor = SQLite連結.find_one("lewis","gearno &gt; ?",[small_gear_no])
    if(gear_type == 1):
        larger_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        larger_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        larger_formfactor = lewis_factor.type3
    else:
        larger_formfactor = lewis_factor.type4
    larger_toothnumber = lewis_factor.gearno
 
    # 找出比目標齒數小的其中的最大的,就是最鄰近的小值
    lewis_factor = SQLite連結.find_one("lewis","gearno &lt; ? order by gearno DESC",[small_gear_no])
    if(gear_type == 1):
        smaller_formfactor = lewis_factor.type1
    elif(gear_type == 2):
        smaller_formfactor = lewis_factor.type2
    elif(gear_type == 3):
        smaller_formfactor = lewis_factor.type3
    else:
        smaller_formfactor = lewis_factor.type4
    smaller_toothnumber = lewis_factor.gearno
    calculated_factor = larger_formfactor + (small_gear_no - larger_toothnumber) * (larger_formfactor - smaller_formfactor) / (larger_toothnumber - smaller_toothnumber)
    # 只傳回小數點後五位數
    return str(round(calculated_factor, 5))
</t>
<t tx="amd.20151122094546.8"># 改寫為齒面寬的設計函式
@cherrypy.expose
def gear_width(self, horsepower=100, rpm=1000, ratio=4, toothtype=1, safetyfactor=2, material_serialno=1, npinion=18):
    SQLite連結 = Store(SQLiteWriter(_curdir+"/lewis.db", frozen=True))
    outstring = ""
    # 根據所選用的齒形決定壓力角
    if(toothtype == 1 or toothtype == 2):
        壓力角 = 20
    else:
        壓力角 = 25
 
    # 根據壓力角決定最小齒數
    if(壓力角== 20):
        最小齒數 = 18
    else:
        最小齒數 = 12
 
    # 直接設最小齒數
    if int(npinion) &lt;= 最小齒數:
        npinion = 最小齒數
    # 大於400的齒數則視為齒條(Rack)
    if int(npinion) &gt;= 400:
        npinion = 400
 
    # 根據所選用的材料查詢強度值
    # 由 material之序號查 steel 表以得材料之降伏強度S單位為 kpsi 因此查得的值要成乘上1000
    # 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=True 表示不要開放動態資料表的建立
    #SQLite連結 = Store(SQLiteWriter("lewis.db", frozen=True))
    # 指定 steel 資料表
    steel = SQLite連結.new("steel")
    # 資料查詢
    #material = SQLite連結.find_one("steel","unsno=? and treatment=?",[unsno, treatment])
    material = SQLite連結.find_one("steel","serialno=?",[material_serialno])
    # 列出 steel 資料表中的資料筆數
    #print(SQLite連結.count("steel"))
    #print (material.yield_str)
    strengthstress = material.yield_str*1000
    # 由小齒輪的齒數與齒形類別,查詢lewis form factor
    # 先查驗是否有直接對應值
    on_table = SQLite連結.count("lewis","gearno=?",[npinion])
    if on_table == 1:
        # 直接進入設計運算
        #print("直接運算")
        #print(on_table)
        lewis_factor = SQLite連結.find_one("lewis","gearno=?",[npinion])
        #print(lewis_factor.type1)
        # 根據齒形查出 formfactor 值
        if(toothtype == 1):
            formfactor = lewis_factor.type1
        elif(toothtype == 2):
            formfactor = lewis_factor.type2
        elif(toothtype == 3):
            formfactor = lewis_factor.type3
        else:
            formfactor = lewis_factor.type4
    else:
        # 沒有直接對應值, 必須進行查表內插運算後, 再執行設計運算
        #print("必須內插")
        #print(interpolation(npinion, gear_type))
        formfactor = self.interpolation(npinion, toothtype)
 
    # 開始進行設計運算
 
    ngear = int(npinion) * int(ratio)
 
    # 重要的最佳化設計---儘量用整數的diametralpitch
    # 先嘗試用整數算若 diametralpitch 找到100 仍無所獲則改用 0.25 作為增量再不行則宣告 fail
    counter = 0
    i = 0.1
    facewidth = 0
    circularpitch = 0
    while (facewidth &lt;= 3 * circularpitch or facewidth &gt;= 5 * circularpitch):
        diametralpitch = i
        #circularpitch = 3.14159/diametralpitch
        circularpitch = math.pi/diametralpitch
        pitchdiameter = int(npinion)/diametralpitch
        #pitchlinevelocity = 3.14159*pitchdiameter*rpm/12
        pitchlinevelocity = math.pi*pitchdiameter * float(rpm)/12
        transmittedload = 33000*float(horsepower)/pitchlinevelocity
        velocityfactor = 1200/(1200 + pitchlinevelocity)
        # formfactor is Lewis form factor
        # formfactor need to get from table 13-3 and determined ty teeth number and type of tooth
        # formfactor = 0.293
        # 90 is the value get from table corresponding to material type
        facewidth = transmittedload*diametralpitch*float(safetyfactor)/velocityfactor/formfactor/strengthstress
        if(counter&gt;5000):
            outstring += "超過5000次的設計運算,仍無法找到答案!&lt;br /&gt;"
            outstring += "可能所選用的傳遞功率過大,或無足夠強度的材料可以使用!&lt;br /&gt;"
            # 離開while迴圈
            break
        i += 0.1
        counter += 1
    facewidth = round(facewidth, 4)
    if(counter&lt;5000):
        # 先載入 cube 程式測試
        #outstring = self.cube_weblink()
        # 再載入 gear 程式測試
        outstring = self.gear_weblink()

        outstring += "進行"+str(counter)+"次重複運算後,得到合用的facewidth值為:"+str(facewidth)
    return outstring
</t>
<t tx="amd.20151122094546.9">@cherrypy.expose
def cube_weblink(self):
    outstring = '''&lt;script type="text/javascript" src="/static/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/wl_header.js"&gt;
document.writeln ("Error loading Pro/Web.Link header!");
&lt;/script&gt;
&lt;script type="text/javascript" language="JavaScript"&gt;
// 若第三輸入為 false, 表示僅載入 session, 但是不顯示
// ret 為 model open return
 var ret = document.pwl.pwlMdlOpen("cube.prt", "v:/tmp", false);
if (!ret.Status) {
    alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
}
    //將 ProE 執行階段設為變數 session
    var session = pfcGetProESession();
    // 在視窗中打開零件檔案, 並且顯示出來
    var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("cube.prt"));
    var solid = session.GetModel("cube.prt",pfcCreate("pfcModelType").MDL_PART);
    var length,width,myf,myn,i,j,volume,count,d1Value,d2Value;
    // 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("a1");
    // 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("a2");
//改變零件尺寸
    //myf=20;
    //myn=20;
    volume=0;
    count=0;
    try
    {
            // 以下採用 URL 輸入對應變數
            //createParametersFromArguments ();
            // 以下則直接利用 javascript 程式改變零件參數
            for(i=0;i&lt;=5;i++)
            {
                //for(j=0;j&lt;=2;j++)
                //{
                    myf=20.0;
                    myn=10.0+i*0.5;
// 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
         d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
         d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);
// 將處理好的變數值, 指定給對應的零件變數
                    length.Value = d1Value;
                    width.Value = d2Value;
                    //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
                    solid.Regenerate(void null);
                    //利用 GetMassProperty 取得模型的質量相關物件
                    properties = solid.GetMassProperty(void null);
                    //volume = volume + properties.Volume;
volume = properties.Volume;
                    count = count + 1;
alert("執行第"+count+"次,零件總體積:"+volume);
// 將零件存為新檔案
var newfile = document.pwl.pwlMdlSaveAs("cube.prt", "v:/tmp", "cube"+count+".prt");
if (!newfile.Status) {
    alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
}
//} // 內圈 for 迴圈
            } //外圈 for 迴圈
            //alert("共執行:"+count+"次,零件總體積:"+volume);
            //alert("零件體積:"+properties.Volume);
            //alert("零件體積取整數:"+Math.round(properties.Volume));
        }
    catch(err)
        {
            alert ("Exception occurred: "+pfcGetExceptionType (err));
        }
&lt;/script&gt;
'''
    return outstring
</t>
<t tx="amd.20151122094835.1"># coding=utf-8
# 上面的程式內容編碼必須在程式的第一或者第二行才會有作用

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
################# (4) 程式啟動區
# 配合程式檔案所在目錄設定靜態目錄或靜態檔案
application_conf = {'/static':{
        'tools.staticdir.on': True,
        # 程式執行目錄下, 必須自行建立 static 目錄
        'tools.staticdir.dir': _curdir+"/static"},
        '/downloads':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/downloads"},
        '/images':{
        'tools.staticdir.on': True,
        'tools.staticdir.dir': data_dir+"/images"}
    }
    
root = Brython()
root.download = Download()

#root.gear = gear.Gear()

if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示在 OpenSfhit 執行
    application = cherrypy.Application(root, config=application_conf)
else:
    # 避開 winreg 模組無法找到的問題"
    # Ubuntu 14.04, Python 3.4.0, CherryPy 3.5.0
    #cherrypy.config.update({'engine.autoreload_on':False})
    # 表示在近端執行(假如在近端採用 wsgi 模式啟動, 則與 OpenShift 相同
    cherrypy.quickstart(root, config=application_conf)
</t>
<t tx="amd.20151122094835.10">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def drawspuraction(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
    
&lt;!-- 以下為 canvas 畫圖程式 --&gt;
&lt;script type="text/python"&gt;
# 從 browser 導入 document
from browser import document
from math import *
# 請注意, 這裡導入位於 Lib/site-packages 目錄下的 spur.py 檔案
import spur

# 準備在 id="plotarea" 的 canvas 中繪圖
canvas = document["plotarea"]
ctx = canvas.getContext("2d")

# 以下利用 spur.py 程式進行繪圖
# N 為齒數
N = '''+str(N)+'''
# M 為模數
M = '''+str(M)+'''
# 壓力角 P 單位為角度
P = '''+str(P)+'''
# 計算兩齒輪的節圓半徑
rp = N*M/2

spur.Spur(ctx).Gear(600, 600, rp, N, P, "blue")

&lt;/script&gt;
&lt;canvas id="plotarea" width="1200" height="1200"&gt;&lt;/canvas&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;script&gt;
window.onload=function(){
brython();
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.11">@cherrypy.expose
# W 為正方體的邊長
def cube(self, W=10):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 使用者輸入表單的參數交由 cubeaction 方法處理 --&gt;
&lt;form method=POST action=cubeaction&gt;
正方體邊長:&lt;input type=text name=W value='''+str(W)+'''&gt;&lt;br /&gt;
&lt;input type=submit value=送出&gt;
&lt;/form&gt;
&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.12">@cherrypy.expose
# W 為正方體邊長, 內定值為 10
def cubeaction(self, W=10):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 先載入 pfcUtils.js 與 wl_header.js --&gt;
&lt;script type="text/javascript" src="/static/weblink/pfcUtils.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/weblink/wl_header.js"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
document.writeln ("Error loading Pro/Web.Link header!");
&lt;/script&gt;
&lt;script&gt;
window.onload=function(){
brython();
}
&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 不要使用 body 啟動 brython() 改為 window level 啟動 --&gt;
&lt;body onload=""&gt;
&lt;h1&gt;Creo 參數化零件&lt;/h1&gt;
&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;

&lt;!-- 以下為 Creo Pro/Web.Link 程式, 將 JavaScrip 改為 Brython 程式 --&gt;

&lt;script type="text/python"&gt;
from browser import document, window
from math import *

# 這個區域為 Brython 程式範圍, 註解必須採用 Python 格式
# 因為 pfcIsWindows() 為原生的 JavaScript 函式, 在 Brython 中引用必須透過 window 物件
if (!window.pfcIsWindows()) window.netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
# 若第三輸入為 false, 表示僅載入 session, 但是不顯示
# ret 為 model open return
ret = document.pwl.pwlMdlOpen("cube.prt", "v:/tmp", false)
if (!ret.Status):
    window.alert("pwlMdlOpen failed (" + ret.ErrorCode + ")")
    # 將 ProE 執行階段設為變數 session
    session = window.pfcGetProESession()
    # 在視窗中打開零件檔案, 並且顯示出來
    pro_window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("cube.prt"))
    solid = session.GetModel("cube.prt", window.pfcCreate("pfcModelType").MDL_PART)
    # 在 Brython 中與 Python 語法相同, 只有初值設定問題, 無需宣告變數
    # length, width, myf, myn, i, j, volume, count, d1Value, d2Value
    # 將模型檔中的 length 變數設為 javascript 中的 length 變數
    length = solid.GetParam("a1")
    # 將模型檔中的 width 變數設為 javascript 中的 width 變數
    width = solid.GetParam("a2")
    # 改變零件尺寸
    # myf=20
    # myn=20
    volume = 0
    count = 0
    try:
        # 以下採用 URL 輸入對應變數
        # createParametersFromArguments ();
        # 以下則直接利用 javascript 程式改變零件參數
        for i in range(5):
            myf ='''+str(W)+'''
            myn ='''+str(W)+''' + i*2.0
            # 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
            d1Value = window.pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf)
            d2Value = window.pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn)
            # 將處理好的變數值, 指定給對應的零件變數
            length.Value = d1Value
            width.Value = d2Value
            # 零件尺寸重新設定後, 呼叫 Regenerate 更新模型
            # 在 JavaScript 為 null 在 Brython 為 None
            solid.Regenerate(None)
            # 利用 GetMassProperty 取得模型的質量相關物件
            properties = solid.GetMassProperty(None)
            # volume = volume + properties.Volume
            volume = properties.Volume
            count = count + 1
            window.alert("執行第"+count+"次,零件總體積:"+volume)
            # 將零件存為新檔案
            newfile = document.pwl.pwlMdlSaveAs("cube.prt", "v:/tmp", "cube"+count+".prt")
            if (!newfile.Status):
                window.alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")")
            # window.alert("共執行:"+count+"次,零件總體積:"+volume)
            # window.alert("零件體積:"+properties.Volume)
            # window.alert("零件體積取整數:"+Math.round(properties.Volume));
    except:
        window.alert ("Exception occurred: "+window.pfcGetExceptionType (err))
&lt;/script&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.13">@cherrypy.expose
def fileuploadform(self):
    return '''&lt;h1&gt;file upload&lt;/h1&gt;
&lt;script src="/static/jquery.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/axuploader.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script&gt;
$(document).ready(function(){
$('.prova').axuploader({url:'fileaxupload', allowExt:['jpg','png','gif','7z','pdf','zip','flv','stl','swf'],
finish:function(x,files)
    {
        alert('All files have been uploaded: '+files);
    },
enable:true,
remotePath:function(){
return 'downloads/';
}
});
});
&lt;/script&gt;
&lt;div class="prova"&gt;&lt;/div&gt;
&lt;input type="button" onclick="$('.prova').axuploader('disable')" value="asd" /&gt;
&lt;input type="button" onclick="$('.prova').axuploader('enable')" value="ok" /&gt;
&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;
'''</t>
<t tx="amd.20151122094835.14">@cherrypy.expose
def fileaxupload(self, *args, **kwargs):
    filename = kwargs["ax-file-name"]
    flag = kwargs["start"]
    if flag == "0":
        file = open(download_root_dir+"downloads/"+filename, "wb")
    else:
        file = open(download_root_dir+"downloads/"+filename, "ab")
    file.write(cherrypy.request.body.read())
    header= cherrypy.request.body.read(80)
    file.close()
    return "files uploaded!"+header.decode("UTF-8")
</t>
<t tx="amd.20151122094835.15">@cherrypy.expose
def download_list(self, item_per_page=5, page=1, keyword=None, *args, **kwargs):
    files = os.listdir(download_root_dir+"downloads/")
    total_rows = len(files)
    totalpage = math.ceil(total_rows/int(item_per_page))
    starti = int(item_per_page) * (int(page) - 1) + 1
    endi = starti + int(item_per_page) - 1
    outstring = "&lt;form method='post' action='delete_file'&gt;"
    notlast = False
    if total_rows &gt; 0:
        outstring += "&lt;br /&gt;"
        if (int(page) * int(item_per_page)) &lt; total_rows:
            notlast = True
        if int(page) &gt; 1:
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page=1&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&lt;&lt;&lt;/a&gt; "
            page_num = int(page) - 1
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(page_num)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Previous&lt;/a&gt; "
        span = 10
        for index in range(int(page)-span, int(page)+span):
            if index&gt;= 0 and index&lt; totalpage:
                page_now = index + 1 
                if page_now == int(page):
                    outstring += "&lt;font size='+1' color='red'&gt;"+str(page)+" &lt;/font&gt;"
                else:
                    outstring += "&lt;a href='"
                    outstring += "download_list?&amp;amp;page="+str(page_now)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
                    outstring += "'&gt;"+str(page_now)+"&lt;/a&gt; "

        if notlast == True:
            nextpage = int(page) + 1
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(nextpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Next&lt;/a&gt;"
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(totalpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&gt;&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;"
        if (int(page) * int(item_per_page)) &lt; total_rows:
            notlast = True
            outstring += downloadlist_access_list(files, starti, endi)+"&lt;br /&gt;"
        else:
            outstring += "&lt;br /&gt;&lt;br /&gt;"
            outstring += downloadlist_access_list(files, starti, total_rows)+"&lt;br /&gt;"
        
        if int(page) &gt; 1:
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page=1&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&lt;&lt;&lt;/a&gt; "
            page_num = int(page) - 1
            outstring += "&lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(page_num)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Previous&lt;/a&gt; "
        span = 10
        for index in range(int(page)-span, int(page)+span):
        #for ($j=$page-$range;$j&lt;$page+$range;$j++)
            if index &gt;=0 and index &lt; totalpage:
                page_now = index + 1
                if page_now == int(page):
                    outstring += "&lt;font size='+1' color='red'&gt;"+str(page)+" &lt;/font&gt;"
                else:
                    outstring += "&lt;a href='"
                    outstring += "download_list?&amp;amp;page="+str(page_now)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
                    outstring += "'&gt;"+str(page_now)+"&lt;/a&gt; "
        if notlast == True:
            nextpage = int(page) + 1
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(nextpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;Next&lt;/a&gt;"
            outstring += " &lt;a href='"
            outstring += "download_list?&amp;amp;page="+str(totalpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&gt;&gt;&gt;&lt;/a&gt;"
    else:
        outstring += "no data!"
    outstring += "&lt;br /&gt;&lt;br /&gt;&lt;input type='submit' value='delete'&gt;&lt;input type='reset' value='reset'&gt;&lt;/form&gt;"

    return "&lt;div class='container'&gt;&lt;nav&gt;"+ \
        "&lt;/nav&gt;&lt;section&gt;&lt;h1&gt;Download List&lt;/h1&gt;"+outstring+"&lt;br/&gt;&lt;br /&gt;&lt;/body&gt;&lt;/html&gt;"
</t>
<t tx="amd.20151122094835.16">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def threegears(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/Cango2D.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/gearUtils-04.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;body onload="brython()"&gt;

&lt;!-- 以下為 canvas 畫圖程式 --&gt;
&lt;script type="text/python"&gt;
# 從 browser 導入 document
from browser import document
from math import *
# 請注意, 這裡導入位於 Lib/site-packages 目錄下的 spur.py 檔案
import spur

# 準備在 id="plotarea" 的 canvas 中繪圖
canvas = document["plotarea"]
ctx = canvas.getContext("2d")

# 以下利用 spur.py 程式進行繪圖, 接下來的協同設計運算必須要配合使用者的需求進行設計運算與繪圖
# 其中並將工作分配給其他組員建立類似 spur.py 的相關零件繪圖模組
# midx, midy 為齒輪圓心座標, rp 為節圓半徑, n 為齒數, pa 為壓力角, color 為線的顏色
# Gear(midx, midy, rp, n=20, pa=20, color="black"):
# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# m 為模數
m = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 19
# 第3齒輪齒數
n_g3 = 17
# 計算兩齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2

# 繪圖第1齒輪的圓心座標
x_g1 = 280
y_g1 = 400
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
spur.Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-pi/2-pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
spur.Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# pi+pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (pi+pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-pi/2-pi/n_g3+(pi+pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
spur.Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()

# 按照上面三個正齒輪的囓合轉角運算, 隨後的傳動齒輪轉角便可依此類推, 完成6個齒輪的囓合繪圖

&lt;/script&gt;
&lt;canvas id="plotarea" width="1200" height="1200"&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring
</t>
<t tx="amd.20151122094835.17">class Download:
    @others
</t>
<t tx="amd.20151122094835.18">@cherrypy.expose
def index(self, filepath):
    return serve_file(filepath, "application/x-download", "attachment")
</t>
<t tx="amd.20151122094835.2">################# (1) 模組導入區
# 導入 cherrypy 模組, 為了在 OpenShift 平台上使用 cherrypy 模組, 必須透過 setup.py 安裝
import cherrypy
# 導入 Python 內建的 os 模組, 因為 os 模組為 Python 內建, 所以無需透過 setup.py 安裝
import os
# 導入 random 模組
import random
import math
from cherrypy.lib.static import serve_file
# 導入 gear 模組
#import gear

################# (2) 廣域變數設定區
# 確定程式檔案所在目錄, 在 Windows 下有最後的反斜線
_curdir = os.path.join(os.getcwd(), os.path.dirname(__file__))
# 設定在雲端與近端的資料儲存目錄
if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
    # 表示程式在雲端執行
    download_root_dir = os.environ['OPENSHIFT_DATA_DIR']
    data_dir = os.environ['OPENSHIFT_DATA_DIR']
else:
    # 表示程式在近端執行
    download_root_dir = _curdir + "/local_data/"
    data_dir = _curdir + "/local_data/"


</t>
<t tx="amd.20151122094835.3">def sizeof_fmt(num):
    for x in ['bytes','KB','MB','GB']:
        if num &lt; 1024.0:
            return "%3.1f%s" % (num, x)
        num /= 1024.0
    return "%3.1f%s" % (num, 'TB')
</t>
<t tx="amd.20151122094835.4">################# (3) 程式類別定義區
# 以下改用 CherryPy 網際框架程式架構
# 以下為 Hello 類別的設計內容, 其中的 object 使用, 表示 Hello 類別繼承 object 的所有特性, 包括方法與屬性設計
class Brython(object):

    # Midterm 類別的啟動設定
    _cp_config = {
    'tools.encode.encoding': 'utf-8',
    'tools.sessions.on' : True,
    'tools.sessions.storage_type' : 'file',
    #'tools.sessions.locking' : 'explicit',
    # session 以檔案儲存, 而且位於 data_dir 下的 tmp 目錄
    'tools.sessions.storage_path' : data_dir+'/tmp',
    # session 有效時間設為 60 分鐘
    'tools.sessions.timeout' : 60
    }

    @others
</t>
<t tx="amd.20151122094835.5">def __init__(self):
    # hope to create downloads and images directories　
    if not os.path.isdir(download_root_dir+"downloads"):
        try:
            os.makedirs(download_root_dir+"downloads")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"images"):
        try:
            os.makedirs(download_root_dir+"images")
        except:
            print("mkdir error")
    if not os.path.isdir(download_root_dir+"tmp"):
        try:
            os.makedirs(download_root_dir+"tmp")
        except:
            print("mkdir error")
</t>
<t tx="amd.20151122094835.6"># 以 @ 開頭的 cherrypy.expose 為 decorator, 用來表示隨後的成員方法, 可以直接讓使用者以 URL 連結執行
@cherrypy.expose
# index 方法為 CherryPy 各類別成員方法中的內建(default)方法, 當使用者執行時未指定方法, 系統將會優先執行 index 方法
# 有 self 的方法為類別中的成員方法, Python 程式透過此一 self 在各成員方法間傳遞物件內容
def index(self):
    outstring = '''
    &lt;!DOCTYPE html&gt; 
    &lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;a href="spur"&gt;spur&lt;/a&gt;&lt;br /&gt;
    &lt;a href="drawspur"&gt;drawspur&lt;/a&gt;&lt;br /&gt;
    &lt;a href="fileuploadform"&gt;上傳檔案&lt;/a&gt;&lt;br /&gt;
    &lt;a href="download_list"&gt;列出上傳檔案&lt;/a&gt;&lt;br /&gt;
    &lt;a href="threegears"&gt;3個齒輪繪圖&lt;/a&gt;&lt;br /&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    '''
    
    return outstring
</t>
<t tx="amd.20151122094835.7">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def spur(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;body onload="brython()"&gt;
    
&lt;form method=POST action=spuraction&gt;
齒數:&lt;input type=text name=N value='''+str(N)+'''&gt;&lt;br /&gt;
模數:&lt;input type=text name=M value = '''+str(M)+'''&gt;&lt;br /&gt;
壓力角:&lt;input type=text name=P value = '''+str(P)+'''&gt;&lt;br /&gt;
&lt;input type=submit value=send&gt;
&lt;/form&gt;
&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094835.8">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def spuraction(self, N=20, M=5, P=15):
    output = '''
    &lt;!doctype html&gt;&lt;html&gt;
    &lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
    &lt;title&gt;2015CD Midterm&lt;/title&gt;
    &lt;/head&gt; 
    &lt;body&gt;
    '''
    output += "齒數為"+str(N)+"&lt;br /&gt;"
    output += "模數為"+str(M)+"&lt;br /&gt;"
    output += "壓力角為"+str(P)+"&lt;br /&gt;"
    output +='''&lt;br /&gt;&lt;a href="/spur"&gt;spur&lt;/a&gt;(按下後再輸入)&lt;br /&gt;'''
    output +='''&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    '''
    
    return output
    
    </t>
<t tx="amd.20151122094835.9">@cherrypy.expose
# N 為齒數, M 為模數, P 為壓力角
def drawspur(self, N=20, M=5, P=15):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;/head&gt;
&lt;body&gt;
    
&lt;form method=POST action=drawspuraction&gt;
齒數:&lt;input type=text name=N value='''+str(N)+'''&gt;&lt;br /&gt;
模數:&lt;input type=text name=M value = '''+str(M)+'''&gt;&lt;br /&gt;
壓力角:&lt;input type=text name=P value = '''+str(P)+'''&gt;&lt;br /&gt;
&lt;input type=submit value=畫出正齒輪輪廓&gt;
&lt;/form&gt;
&lt;br /&gt;&lt;a href="index"&gt;index&lt;/a&gt;&lt;br /&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.3-20150514-095342/brython.js"&gt;&lt;/script&gt;
&lt;script&gt;
window.onload=function(){
brython();
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

    return outstring</t>
<t tx="amd.20151122094920.1">@language python
#coding: utf-8
import math
# 導入數學函式後, 圓周率為 pi
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 以下分別為正齒輪繪圖與主 tkinter 畫布繪圖
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 注意 n 為 52 齒時繪圖產生錯誤, 因為 base circle 與齒根圓大小未進行判斷, 必須要修正
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
</t>
<t tx="amd.20151122095255.1">@language python
 
import cherrypy
 
# 這是 MAN 類別的定義
'''
# 在 application 中導入子模組
import programs.cdag30.man as cdag30_man
# 加入 cdag30 模組下的 man.py 且以子模組 man 對應其 MAN() 類別
root.cdag30.man = cdag30_man.MAN()
 
# 完成設定後, 可以利用
/cdag30/man/assembly
# 呼叫 man.py 中 MAN 類別的 assembly 方法
'''
class MAN(object):
    # 各組利用 index 引導隨後的程式執行
    @cherrypy.expose
    def index(self, *args, **kwargs):
        outstring = '''
這是 2014CDA 協同專案下的 cdag30 模組下的 MAN 類別.&lt;br /&gt;&lt;br /&gt;
&lt;!-- 這裡採用相對連結, 而非網址的絕對連結 (這一段為 html 註解) --&gt;
&lt;a href="assembly"&gt;執行  MAN 類別中的 assembly 方法&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;
請確定下列零件於 V:/home/lego/man 目錄中, 且開啟空白 Creo 組立檔案.&lt;br /&gt;
&lt;a href="/static/lego_man.7z"&gt;lego_man.7z&lt;/a&gt;(滑鼠右鍵存成 .7z 檔案)&lt;br /&gt;
'''
        return outstring
 
    @cherrypy.expose
    def assembly(self, *args, **kwargs):
        outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/weblink/examples/jscript/pfcUtils.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/script&gt;&lt;script language="JavaScript"&gt;
/*設計一個零件組立函式*/
// featID 為組立件第一個組立零件的編號
// inc 則為 part1 的組立順序編號, 第一個入組立檔編號為 featID+0
// part2 為外加的零件名稱
function axis_plane_assembly(session, assembly, transf, featID, inc, part2, axis1, plane1, axis2, plane2){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
ids.Append(featID+inc);
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var asmDatums = new Array(axis1, plane1);
var compDatums = new Array(axis2, plane2);
var relation = new Array (pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate("pfcComponentConstraints");
    for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
        constrs.Append(constr);
    }
asmcomp.SetConstraints(constrs, void null);
}
// 以上為 axis_plane_assembly() 函式
//
function three_plane_assembly(session, assembly, transf, featID, inc, part2, plane1, plane2, plane3, plane4, plane5, plane6){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
ids.Append(featID+inc);
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var constrs = pfcCreate("pfcComponentConstraints");
var asmDatums = new Array(plane1, plane2, plane3);
var compDatums = new Array(plane4, plane5, plane6);
var MpfcSelect = pfcCreate("MpfcSelect");
for (var i = 0; i &lt; 3; i++)
{
    var asmItem = subassembly.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
     
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var compItem = componentModel.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create(pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
    constr.AssemblyReference = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
    constrs.Append(constr);
}
asmcomp.SetConstraints(constrs, void null);
}
// 以上為 three_plane_assembly() 函式
//
// 假如 Creo 所在的操作系統不是 Windows 環境
if (!pfcIsWindows())
// 則啟動對應的 UniversalXPConnect 執行權限 (等同 Windows 下的 ActiveX)
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// pfcGetProESession() 是位於 pfcUtils.js 中的函式, 確定此 JavaScript 是在嵌入式瀏覽器中執行
var session = pfcGetProESession();
// 設定 config option, 不要使用元件組立流程中內建的假設約束條件
session.SetConfigOption("comp_placement_assumptions","no");
// 建立擺放零件的位置矩陣, Pro/Web.Link 中的變數無法直接建立, 必須透過 pfcCreate() 建立
var identityMatrix = pfcCreate("pfcMatrix3D");
// 建立 identity 位置矩陣
for (var x = 0; x &lt; 4; x++)
for (var y = 0; y &lt; 4; y++)
{
    if (x == y)
        identityMatrix.Set(x, y, 1.0);
    else
        identityMatrix.Set(x, y, 0.0);
}
// 利用 identityMatrix 建立 transf 座標轉換矩陣
var transf = pfcCreate("pfcTransform3D").Create(identityMatrix);
// 取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
// 以目前已開檔的空白組立檔案, 作為 model
var model = session.CurrentModel;
// 查驗有無 model, 或 model 類別是否為組立件, 若不符合條件則丟出錯誤訊息
if (model == void null || model.Type != pfcCreate("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
// 將此模型設為組立物件
var assembly = model;
 
/**---------------------- LEGO_BODY--------------------**/
// 設定零件的 descriptor 物件變數
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName("v:/home/lego/man/LEGO_BODY.prt");
// 若零件在 session 則直接取用
var componentModel = session.GetModelFromDescr(descr);
// 若零件不在 session 則從工作目錄中載入 session
var componentModel = session.RetrieveModel(descr);
// 若零件已經在 session 中則放入組立檔中
if (componentModel != void null)
{
    // 注意這個 asmcomp 即為設定約束條件的本體
    // asmcomp 為特徵物件, 直接將零件, 以 transf 座標轉換矩陣方位放入組立檔案中
    var asmcomp = assembly.AssembleComponent(componentModel, transf);
}
 
// 建立約束條件變數
var constrs = pfcCreate("pfcComponentConstraints");
// 設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT, 可在組立件-&gt;info-&gt;model 中查詢定位面名稱
// 組立檔案中的 Datum 名稱也可以利用 View-&gt;plane tag display 查詢名稱
// 建立組立參考面所組成的陣列
var asmDatums = new Array("ASM_FRONT", "ASM_TOP", "ASM_RIGHT");
// 設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
var compDatums = new Array("FRONT", "TOP", "RIGHT");
// 建立 ids 變數, intseq 為 sequence of integers 為資料類別, 使用者可以經由整數索引擷取此資料類別的元件, 第一個索引為 0
       // intseq 等同 Python 的數列資料?
var ids = pfcCreate("intseq");
// 利用 assembly 物件模型, 建立路徑變數
var path = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
// 採用互動式設定相關的變數, MpfcSelect 為 Module level class 中的一種
var MpfcSelect = pfcCreate("MpfcSelect");
// 利用迴圈分別約束組立與零件檔中的三個定位平面
for (var i = 0; i &lt; 3; i++)
{
// 設定組立參考面, 也就是 "ASM_FRONT", "ASM_TOP", "ASM_RIGHT" 等三個 datum planes
var asmItem = assembly.GetItemByName (pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
// 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
if (asmItem == void null)
{
    interactFlag = true;
    continue;
}
// 設定零件參考面, 也就是 "FRONT", "TOP", "RIGHT" 等三個 datum planes
var compItem = componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
// 若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
if (compItem == void null)
{
    interactFlag = true;
    continue;
}
        // 因為 asmItem 為組立件中的定位特徵, 必須透過 path 才能取得
var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, path);
        // 而 compItem 則為零件, 沒有 path 路徑, 因此第二變數為 null
var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
        // 利用 ASM_CONSTRAINT_ALIGN 對齊組立約束建立約束變數
var constr = pfcCreate("pfcComponentConstraint").Create (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
        // 設定約束條件的組立參考與元件參考選擇
constr.AssemblyReference = asmSel;
constr.ComponentReference = compSel;
       // 第一個變數為強制變數, 第二個為忽略變數
       // 強制變數為 false, 表示不強制約束, 只有透過點與線對齊時需設為 true
       // 忽略變數為 false, 約束條件在更新模型時是否忽略, 設為 false 表示不忽略
       // 通常在組立 closed chain 機構時,  忽略變數必須設為 true, 才能完成約束
       // 因為三個面絕對約束, 因此輸入變數為 false, false
constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
// 將互動選擇相關資料, 附加在程式約束變數之後
constrs.Append(constr);
}
 
// 設定組立約束條件
asmcomp.SetConstraints (constrs, void null);
/**---------------------- LEGO_ARM_RT 右手上臂--------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/LEGO_ARM_RT.prt");
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
        // 注意這個 asmcomp 即為設定約束條件的本體
        // asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
// 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
// 此一 featID 為組立件中的第一個零件編號, 也就是樂高人偶的 body
var featID = components.Item(0).Id;
 
ids.Append(featID);
// 在 assembly 模型中建立子零件所對應的路徑
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
// 以下針對 body 的 A_13 軸與 DTM1 基準面及右臂的  A_4 軸線與 DTM1 進行對齊與面接約束
var asmDatums = new Array("A_13", "DTM1");
var compDatums = new Array("A_4", "DTM1");
// 組立的關係變數為對齊與面接
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
// 組立元件則為軸與平面
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
// 建立約束條件變數, 軸採對齊而基準面則以面接進行約束
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
{
                  // 設定組立參考面, asmItem 為 model item
    var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
                  // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 設定零件參考面, compItem 為 model item
    var compItem = componentModel.GetItemByName (relationItem[i], compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 採用互動式設定相關的變數
    var MpfcSelect = pfcCreate ("MpfcSelect");
    var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
    constr.AssemblyReference  = asmSel;
    constr.ComponentReference = compSel;
                  // 因為透過軸線對齊, 第一 force 變數需設為 true
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
                  // 將互動選擇相關資料, 附加在程式約束變數之後
    constrs.Append(constr);
}
// 設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
// 請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
asmcomp.SetConstraints (constrs, void null);
/**---------------------- LEGO_ARM_LT 左手上臂--------------------**/
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/LEGO_ARM_LT.prt");
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
        // 注意這個 asmcomp 即為設定約束條件的本體
        // asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
var asmcomp = assembly.AssembleComponent(componentModel, transf);
}
// 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
var ids = pfcCreate ("intseq");
// 因為左臂也是與 body 進行約束條件組立,  因此取 body 的 featID
// 至此右臂 id 應該是 featID+1, 而左臂則是 featID+2
ids.Append(featID);
// 在 assembly 模型中建立子零件所對應的路徑
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var asmDatums = new Array("A_9", "DTM2");
var compDatums = new Array("A_4", "DTM1");
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
// 建立約束條件變數
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
{
                  // 設定組立參考面, asmItem 為 model item
    var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
                  // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 設定零件參考面, compItem 為 model item
    var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 採用互動式設定相關的變數
    var MpfcSelect = pfcCreate ("MpfcSelect");
    var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
    constr.AssemblyReference  = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
                  // 將互動選擇相關資料, 附加在程式約束變數之後
    constrs.Append(constr);
}
// 設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
// 請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
asmcomp.SetConstraints (constrs, void null);
/**---------------------- LEGO_HAND 右手手腕--------------------**/
// 右手臂 LEGO_ARM_RT.prt 基準  A_2, DTM2
// 右手腕 LEGO_HAND.prt 基準 A_1, DTM3
var descr = pfcCreate ("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/LEGO_HAND.prt");
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
        // 注意這個 asmcomp 即為設定約束條件的本體
        // asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
// 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
var ids = pfcCreate ("intseq");
 
// 組立件中 LEGO_BODY.prt 編號為 featID
// LEGO_ARM_RT.prt 則是組立件第二個置入的零件,  編號為 featID+1
ids.Append(featID+1);
// 在 assembly 模型中, 根據子零件的編號, 建立子零件所對應的路徑
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
// 以下針對 LEGO_ARM_RT 的 A_2 軸與 DTM2 基準面及 HAND 的  A_1 軸線與 DTM3 進行對齊與面接約束
var asmDatums = new Array("A_2", "DTM2");
var compDatums = new Array("A_1", "DTM3");
// 組立的關係變數為對齊與面接
var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
// 組立元件則為軸與平面
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
// 建立約束條件變數, 軸採對齊而基準面則以面接進行約束
var constrs = pfcCreate ("pfcComponentConstraints");
for (var i = 0; i &lt; 2; i++)
{
                  // 設定組立參考面, asmItem 為 model item
    var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
                  // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 設定零件參考面, compItem 為 model item
    var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
                  // 採用互動式設定相關的變數
    var MpfcSelect = pfcCreate("MpfcSelect");
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
    constr.AssemblyReference  = asmSel;
    constr.ComponentReference = compSel;
                  // 因為透過軸線對齊, 第一 force 變數需設為 true
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
                  // 將互動選擇相關資料, 附加在程式約束變數之後
    constrs.Append(constr);
}
// 設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
// 請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
asmcomp.SetConstraints (constrs, void null);
// 利用函式呼叫組立左手 HAND
axis_plane_assembly(session, assembly, transf, featID, 2, 
                              "LEGO_HAND.prt", "A_2", "DTM2", "A_1", "DTM3");
// 利用函式呼叫組立人偶頭部 HEAD
// BODY id 為 featID+0, 以 A_2 及  DTM3 約束
// HEAD 則直接呼叫檔案名稱, 以 A_2, DTM2 約束
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_HEAD.prt", "A_2", "DTM3", "A_2", "DTM2");
// Body 與 WAIST 採三個平面約束組立
// Body 組立面為 DTM4, DTM5, DTM6
// WAIST 組立面為 DTM1, DTM2, DTM3
three_plane_assembly(session, assembly, transf, featID, 0, "LEGO_WAIST.prt", "DTM4", "DTM5", "DTM6", "DTM1", "DTM2", "DTM3"); 
// 右腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_RT.prt", "A_8", "DTM4", "A_10", "DTM1");
// 左腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_LT.prt", "A_8", "DTM5", "A_10", "DTM1");
// 紅帽
axis_plane_assembly(session, assembly, transf, featID, 5, 
                              "LEGO_HAT.prt", "A_2", "TOP", "A_2", "FRONT");
// regenerate 並且 repaint 組立檔案
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();    
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
        return outstring</t>
<t tx="amd.20151122095546.1">@language python
 
import cherrypy
 
# 這是 MAN 類別的定義
'''
# 在 application 中導入子模組
import programs.cdag30.man as cdag30_man
# 加入 cdag30 模組下的 man.py 且以子模組 man 對應其 MAN() 類別
root.cdag30.man = cdag30_man.MAN()
 
# 完成設定後, 可以利用
/cdag30/man/assembly
# 呼叫 man.py 中 MAN 類別的 assembly 方法
'''
class MAN(object):
    # 各組利用 index 引導隨後的程式執行
    @cherrypy.expose
    def index(self, *args, **kwargs):
        outstring = '''
這是 2014CDA 協同專案下的 cdag30 模組下的 MAN 類別.&lt;br /&gt;&lt;br /&gt;
&lt;!-- 這裡採用相對連結, 而非網址的絕對連結 (這一段為 html 註解) --&gt;
&lt;a href="assembly"&gt;執行  MAN 類別中的 assembly 方法&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;
請確定下列零件於 V:/home/lego/man 目錄中, 且開啟空白 Creo 組立檔案.&lt;br /&gt;
&lt;a href="/static/lego_man.7z"&gt;lego_man.7z&lt;/a&gt;(滑鼠右鍵存成 .7z 檔案)&lt;br /&gt;
'''
        return outstring
 
    @cherrypy.expose
    def assembly(self, *args, **kwargs):
        outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/weblink/examples/jscript/pfcUtils.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/script&gt;&lt;script language="JavaScript"&gt;
/*man2.py 完全利用函式呼叫進行組立*/
/*設計一個零件組立函式*/
// featID 為組立件第一個組立零件的編號
// inc 則為 part1 的組立順序編號, 第一個入組立檔編號為 featID+0
// part2 為外加的零件名稱
////////////////////////////////////////////////
// axis_plane_assembly 組立函式
////////////////////////////////////////////////
function axis_plane_assembly(session, assembly, transf, featID, inc, part2, axis1, plane1, axis2, plane2){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
ids.Append(featID+inc);
var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
subassembly = subPath.Leaf;
var asmDatums = new Array(axis1, plane1);
var compDatums = new Array(axis2, plane2);
var relation = new Array (pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS, pfcCreate("pfcModelItemType").ITEM_SURFACE);
var constrs = pfcCreate("pfcComponentConstraints");
    for (var i = 0; i &lt; 2; i++)
    {
        var asmItem = subassembly.GetItemByName (relationItem[i], asmDatums [i]);
        if (asmItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var compItem = componentModel.GetItemByName (relationItem[i], compDatums [i]);
        if (compItem == void null)
        {
            interactFlag = true;
            continue;
        }
        var MpfcSelect = pfcCreate ("MpfcSelect");
        var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
        var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
        var constr = pfcCreate("pfcComponentConstraint").Create (relation[i]);
        constr.AssemblyReference  = asmSel;
        constr.ComponentReference = compSel;
        constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (true, false);
        constrs.Append(constr);
    }
asmcomp.SetConstraints(constrs, void null);
}
// 以上為 axis_plane_assembly() 函式
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// three_plane_assembly 採 align 組立, 若 featID 為 0 表示為空組立檔案
///////////////////////////////////////////////////////////////////////////////////////////////////////////
function three_plane_assembly(session, assembly, transf, featID, inc, part2, plane1, plane2, plane3, plane4, plane5, plane6){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
// 若 featID 為 0 表示為空組立檔案
if (featID != 0){
    ids.Append(featID+inc);
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = subPath.Leaf;
    }else{
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = assembly;
    // 設法取得第一個組立零件 first_featID
    // 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
    var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
    // 此一 featID 為組立件中的第一個零件編號, 也就是樂高人偶的 body
    var first_featID = components.Item(0).Id;
    }
var constrs = pfcCreate("pfcComponentConstraints");
var asmDatums = new Array(plane1, plane2, plane3);
var compDatums = new Array(plane4, plane5, plane6);
var MpfcSelect = pfcCreate("MpfcSelect");
for (var i = 0; i &lt; 3; i++)
{
    var asmItem = subassembly.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
     
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var compItem = componentModel.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create(pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
    constr.AssemblyReference = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
    constrs.Append(constr);
}
asmcomp.SetConstraints(constrs, void null);
// 若 featID = 0 則傳回 first_featID
if (featID == 0)
    return first_featID;
}
// 以上為 three_plane_assembly() 函式
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// three_plane_assembly2 採 mate 組立, 若 featID 為 0 表示為空組立檔案
///////////////////////////////////////////////////////////////////////////////////////////////////////////
function three_plane_assembly2(session, assembly, transf, featID, inc, part2, plane1, plane2, plane3, plane4, plane5, plane6){
var descr = pfcCreate("pfcModelDescriptor").CreateFromFileName ("v:/home/lego/man/"+part2);
var componentModel = session.GetModelFromDescr(descr);
var componentModel = session.RetrieveModel(descr);
if (componentModel != void null)
{
    var asmcomp = assembly.AssembleComponent (componentModel, transf);
}
var ids = pfcCreate("intseq");
// 若 featID 為 0 表示為空組立檔案
if (featID != 0){
    ids.Append(featID+inc);
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = subPath.Leaf;
    }else{
    var subPath = pfcCreate("MpfcAssembly").CreateComponentPath(assembly, ids);
    subassembly = assembly;
    // 設法取得第一個組立零件 first_featID
    // 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
    var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
    // 此一 featID 為組立件中的第一個零件編號, 也就是樂高人偶的 body
    var first_featID = components.Item(0).Id;
    }
var constrs = pfcCreate("pfcComponentConstraints");
var asmDatums = new Array(plane1, plane2, plane3);
var compDatums = new Array(plane4, plane5, plane6);
var MpfcSelect = pfcCreate("MpfcSelect");
for (var i = 0; i &lt; 3; i++)
{
    var asmItem = subassembly.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, asmDatums[i]);
     
    if (asmItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var compItem = componentModel.GetItemByName(pfcCreate("pfcModelItemType").ITEM_SURFACE, compDatums[i]);
    if (compItem == void null)
    {
        interactFlag = true;
        continue;
    }
    var asmSel = MpfcSelect.CreateModelItemSelection(asmItem, subPath);
    var compSel = MpfcSelect.CreateModelItemSelection(compItem, void null);
    var constr = pfcCreate("pfcComponentConstraint").Create(pfcCreate("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
    constr.AssemblyReference = asmSel;
    constr.ComponentReference = compSel;
    constr.Attributes = pfcCreate("pfcConstraintAttributes").Create (false, false);
    constrs.Append(constr);
}
asmcomp.SetConstraints(constrs, void null);
// 若 featID = 0 則傳回 first_featID
if (featID == 0)
    return first_featID;
}
// 以上為 three_plane_assembly2() 函式, 主要採三面 MATE 組立
//
// 假如 Creo 所在的操作系統不是 Windows 環境
if (!pfcIsWindows())
// 則啟動對應的 UniversalXPConnect 執行權限 (等同 Windows 下的 ActiveX)
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
// pfcGetProESession() 是位於 pfcUtils.js 中的函式, 確定此 JavaScript 是在嵌入式瀏覽器中執行
var session = pfcGetProESession();
// 設定 config option, 不要使用元件組立流程中內建的假設約束條件
session.SetConfigOption("comp_placement_assumptions","no");
// 建立擺放零件的位置矩陣, Pro/Web.Link 中的變數無法直接建立, 必須透過 pfcCreate() 建立
var identityMatrix = pfcCreate("pfcMatrix3D");
// 建立 identity 位置矩陣
for (var x = 0; x &lt; 4; x++)
for (var y = 0; y &lt; 4; y++)
{
    if (x == y)
        identityMatrix.Set(x, y, 1.0);
    else
        identityMatrix.Set(x, y, 0.0);
}
// 利用 identityMatrix 建立 transf 座標轉換矩陣
var transf = pfcCreate("pfcTransform3D").Create(identityMatrix);
// 取得目前的工作目錄
var currentDir = session.getCurrentDirectory();
// 以目前已開檔的空白組立檔案, 作為 model
var model = session.CurrentModel;
// 查驗有無 model, 或 model 類別是否為組立件, 若不符合條件則丟出錯誤訊息
if (model == void null || model.Type != pfcCreate("pfcModelType").MDL_ASSEMBLY)
throw new Error (0, "Current model is not an assembly.");
// 將此模型設為組立物件
var assembly = model;
 
/////////////////////////////////////////////////////////////////
// 開始執行組立, 全部採函式呼叫組立
/////////////////////////////////////////////////////////////////
 
// Body 與空組立檔案採三個平面約束組立
// 空組立面為 ASM_TOP, ASM_FRONT, ASM_RIGHT
// Body 組立面為 TOP, FRONT, RIGHT
// 若 featID=0 表示為空組立檔案, 而且函式會傳回第一個組立件的 featID
var featID = three_plane_assembly(session, assembly, transf, 0, 0, "LEGO_BODY.prt", "ASM_TOP", "ASM_FRONT", "ASM_RIGHT", "TOP", "FRONT", "RIGHT"); 
// 利用函式呼叫組立右手 ARM, 組立增量次序為 1
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_ARM_RT.prt", "A_13", "DTM1", "A_4", "DTM1");
// 利用函式呼叫組立左手 ARM, 組立增量次序為 2
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_ARM_LT.prt", "A_9", "DTM2", "A_4", "DTM1");
// 利用函式呼叫組立右手 HAND, 組立增量次序為 3
axis_plane_assembly(session, assembly, transf, featID, 1, 
                              "LEGO_HAND.prt", "A_2", "DTM2", "A_1", "DTM3");
// 利用函式呼叫組立左手 HAND, 組立增量次序為 4
axis_plane_assembly(session, assembly, transf, featID, 2, 
                              "LEGO_HAND.prt", "A_2", "DTM2", "A_1", "DTM3");
// 利用函式呼叫組立人偶頭部 HEAD, 組立增量次序為 5
// BODY id 為 featID+0, 以 A_2 及  DTM3 約束
// HEAD 則直接呼叫檔案名稱, 以 A_2, DTM2 約束
axis_plane_assembly(session, assembly, transf, featID, 0, 
                              "LEGO_HEAD.prt", "A_2", "DTM3", "A_2", "DTM2");
// Body 與 WAIST 採三個平面約束組立
// Body 組立面為 DTM4, DTM5, DTM6
// WAIST 組立面為 DTM1, DTM2, DTM3, 組立增量次序為 6, 與 body 採三面 mate 組立
three_plane_assembly2(session, assembly, transf, featID, 0, "LEGO_WAIST.prt", "DTM4", "DTM5", "DTM6", "DTM1", "DTM2", "DTM3"); 
// 右腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_RT.prt", "A_8", "DTM4", "A_10", "DTM1");
// 左腳
axis_plane_assembly(session, assembly, transf, featID, 6, 
                              "LEGO_LEG_LT.prt", "A_8", "DTM5", "A_10", "DTM1");
// 紅帽
axis_plane_assembly(session, assembly, transf, featID, 5, 
                              "LEGO_HAT.prt", "A_2", "TOP", "A_2", "FRONT"); 
// regenerate 並且 repaint 組立檔案
assembly.Regenerate (void null);
session.GetModelWindow (assembly).Repaint();    
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
        return outstring</t>
<t tx="amd.20151122095724.1">#STL Binary 轉為 ASCII
import struct
normals = []
points = []
triangles = []
triangle_number = 0
def load_binary_stl(fp):
    '''
    二位元 STL 檔案格式如下:
    檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆
    UINT8[80] – Header
    UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)
      
    foreach triangle
    REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)
    REAL32[3] – Vertex 1
    REAL32[3] – Vertex 2
    REAL32[3] – Vertex 3
    UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)
    end
      
    '''
    # 已經在外部開檔
    #fp=open(filename,'rb')
    header=fp.read(80)
    triangle_number = struct.unpack('I',fp.read(4))[0]
    #print(triangle_number)
    count=0
    while True:
        try:
            p=fp.read(12)
            if len(p)==12:
                n=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                normals.append(n)
                l = len(points)
                #print(n)
            p=fp.read(12)
            if len(p)==12:
                p1=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p1)
                #print(p1)
            p=fp.read(12)
            if len(p)==12:
                p2=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p2)
            p=fp.read(12)
            if len(p)==12:
                p3=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p3)
                triangles.append((l, l+1, l+2))
            # 使用 count 來計算三角形平面個數
            # triangle_number 為 STL 檔案中的三角形個數
            count += 1
            #print(count)
            # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為
            # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute
            fp.read(2)
            # 讀完所有三角平面後, 即跳出 while
            if count &gt; triangle_number:
                break
        except EOFError:
            break
    #fp.close()
def read_length(f):
    length = struct.unpack("@i", f.read(4))
    return length[0]
def read_header(f):
    f.seek(f.tell()+80)
def write_as_ascii(outfilename):
    f = open(outfilename, "w")
    f.write ("solid "+outfilename+"\n")
    for n  in range(len(triangles)):
        f.write ("facet normal {} {} {}\n".format(normals[n][0],normals[n][1],normals[n][2]))
        f.write ("outer loop\n")
        f.write ("vertex {} {} {}\n".format(points[triangles[n][0]][0],points[triangles[n][0]][1],points[triangles[n][0]][2]))
        f.write ("vertex {} {} {}\n".format(points[triangles[n][1]][0],points[triangles[n][1]][1],points[triangles[n][1]][2]))
        f.write ("vertex {} {} {}\n".format(points[triangles[n][2]][0],points[triangles[n][2]][1],points[triangles[n][2]][2]))
        f.write ("endloop\n")
        f.write ("endfacet\n")
    f.write ("endsolid "+outfilename+"\n")
    f.close()
def main():
    infilename = "ss1.stl"
    outfilename = "ss2.stl"
    try:
        f = open(infilename, "rb")
        #read_header(f)
        #l = read_length(f)
        try:
            load_binary_stl(f)
            l = len(normals)
        except Exception as e:
            print("Exception",e)
        print(len(normals), len(points), len(triangles), l)
        write_as_ascii(outfilename)
        print("done")
    except Exception as e:
        print(e)
if __name__ == '__main__':
    main()</t>
<t tx="amd.20151122095840.1">#coding: utf-8
import struct
      
class StLFacet:
    def __init__(self, normal, v1, v2, v3, att_bc=0):
        self.coords = [normal, v1, v2, v3]
        self.att_bc = att_bc
  
class StL:
    def __init__(self, header):
        self.header = header
        self.facets = []
    def add_facet(self, facet):
        self.facets.append(facet)
    def get_binary(self):
        # 原先 2.0 的版本
        #out = ['%-80.80s' % self.header]
        # 改為 Python 3.0 格式
        # 第一行標頭的格式
        header = ['%-80.80s' % self.header][0]
        # 利用 bytes() 將標頭字串轉為二位元資料
        out = [bytes(header,encoding="utf-8")]
        # 接著則計算三角形面的數量, 並以二位元長整數格式存檔
        out.append(struct.pack('L',len(self.facets)))
        # 接著則依照法線向量與三個點座標的格式, 分別以浮點數格式進行資料附加
        for f in self.facets:
            for coord in f.coords:
                out.append(struct.pack('3f', *coord))
            # att_bc 則內定為 0
            out.append(struct.pack('H', f.att_bc))
        return b"".join(out)
  
def test():
    stl=StL('Header ...')
    stl.add_facet(StLFacet((0.,0.,1.),(0.,0.,0.),(1.,0.,0.),(0.,1.,0.)))
    stl.add_facet(StLFacet((0.,0.,1.),(1.,0.,0.),(1.,1.,0.),(0.,1.,0.)))
    # 第二個平面
    stl.add_facet(StLFacet((0.,-1.,0.),(0.,0.,0.),(0.,0.,-1.),(1.,0.,-1.)))
    stl.add_facet(StLFacet((0.,-1.,0.),(0.,0.,0.),(1.,0.,-1.),(1.,0.,0.)))
    return stl.get_binary()
  
# 指定存為 binary 格式檔案
stlfile = open("test.stl", "wb")
stlcontent = test()
stlfile.write(stlcontent)</t>
<t tx="amd.20151122100250.1"># https://github.com/coursemdetw/2015cd/blob/87783b8a4321336493c533152b4ce1e354ece867/wsgi.py
@cherrypy.expose
def index(self, guess=None):
    # 將標準答案存入 answer session 對應區
    theanswer = random.randint(1, 100)
    thecount = 0
    # 將答案與計算次數變數存進 session 對應變數
    cherrypy.session['answer'] = theanswer
    cherrypy.session['count'] = thecount
    # 印出讓使用者輸入的超文件表單
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;!-- 載入 brython.js --&gt;
&lt;script type="text/javascript" src="/static/Brython3.1.0-20150301-090019/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/Cango2D.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/static/gearUtils-04.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;!-- 啟動 brython() --&gt;
&lt;body onload="brython()"&gt;
     
&lt;form method=POST action=doCheck&gt;
請輸入您所猜的整數:&lt;input type=text name=guess&gt;&lt;br /&gt;
&lt;input type=submit value=send&gt;
&lt;/form&gt;
&lt;hr&gt;
&lt;!-- 以下在網頁內嵌 Brython 程式 --&gt;
&lt;script type="text/python"&gt;
from browser import document, alert
 
def echo(ev):
    alert(document["zone"].value)
 
# 將文件中名稱為 mybutton 的物件, 透過 click 事件與 echo 函式 bind 在一起
document['mybutton'].bind('click',echo)
&lt;/script&gt;
&lt;input id="zone"&gt;&lt;button id="mybutton"&gt;click !&lt;/button&gt;
&lt;hr&gt;
&lt;!-- 以下為 canvas 畫圖程式 --&gt;
&lt;script type="text/python"&gt;
# 從 browser 導入 document
from browser import document
import math
 
# 畫布指定在名稱為 plotarea 的 canvas 上
canvas = document["plotarea"]
ctx = canvas.getContext("2d")
 
# 用紅色畫一條直線
ctx.beginPath()
ctx.lineWidth = 3
ctx.moveTo(0, 0)
ctx.lineTo(0, 500)
ctx.strokeStyle = "red"
ctx.stroke()
 
# 用藍色再畫一條直線
ctx.beginPath()
ctx.lineWidth = 3
ctx.moveTo(0, 0)
ctx.lineTo(500, 0)
ctx.strokeStyle = "blue"
ctx.stroke()
 
# 用綠色再畫一條直線
ctx.beginPath()
ctx.lineWidth = 3
ctx.moveTo(0, 0)
ctx.lineTo(500, 500)
ctx.strokeStyle = "green"
ctx.stroke()
 
# 用黑色畫一個圓
ctx.beginPath()
ctx.lineWidth = 3
ctx.strokeStyle = "black"
ctx.arc(250,250,50,0,2*math.pi)
ctx.stroke()
&lt;/script&gt;
&lt;canvas id="plotarea" width="800" height="600"&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
 
    return outstring</t>
<t tx="amd.20151122100400.1"># http://2014c2-mdenfu.rhcloud.com/c2g30/flag
@cherrypy.expose
def flag(self, *args, **kwargs):
    '''
    原始程式來源: http://blog.roodo.com/esabear/archives/19215194.html
    改寫為 Brython 程式
    '''
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython2.1.0-20140419-113919/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="300" height="200"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import doc
import math
 
# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二到光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
# 查詢 canvas arc 如何定義
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, true)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, true)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
<t tx="amd.20151122100546.1"># http://2014c2-mdenfu.rhcloud.com/c2g30/star
@cherrypy.expose
def star(self, *args, **kwargs):
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython2.1.0-20140419-113919/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import doc
import math
 
# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 800 光點
ctx.setTransform(1, 0, 0, -1, 0, 800)
 
# 定義畫線函式
def draw_line(x1, y1, x2, y2, linethick = 3, color = "black"):
    ctx.beginPath()
    ctx.lineWidth = linethick
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()
 
# x, y 為中心,  r 為半徑, angle 旋轉角,  solid 空心或實心,  color 顏色
def star(x, y, r, angle=0, solid=False, color="#f00"):
    # 以 x, y 為圓心, 計算五個外點
    deg = math.pi/180
    # 圓心到水平線距離
    a = r*math.cos(72*deg)
    # a 頂點向右到內點距離
    b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg)
    # 利用畢氏定理求內點半徑
    rin = math.sqrt(a**2 + b**2)
    # 查驗 a, b 與 rin
    #print(a, b, rin)
    if(solid):
        ctx.beginPath()
    for i in range(5):
        xout = (x + r*math.sin((360/5)*deg*i+angle*deg))
        yout = (y + r*math.cos((360/5)*deg*i+angle*deg))
        # 外點增量 + 1
        xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg)
        yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg)
        xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg)
        yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg)
        # 查驗外點與內點座標
        #print(xout, yout, xin, yin)
        if(solid):
            # 填色
            if(i==0):
                ctx.moveTo(xout, yout)
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
            else:
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
        else:
            # 空心
            draw_line(xout, yout, xin, yin, color)
            # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關
            draw_line(xout2, yout2, xin, yin, color)
    if(solid):
        ctx.fillStyle = color
        ctx.fill()
star(600, 600, 100, 30, True, "#00f")
star(100, 100, 30, 0, True, "#f00")
#star(300, 300, 50, 0, False, "#000")
for i in range(5):
    for j in range(5):
        star(200+65*i, 200+65*j, 30, 0, False, "#000")
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
<t tx="amd.20151122102956.1">http://threejs.org/</t>
<t tx="amd.20151122214658.1">http://blog.bobbyallen.me/2014/01/11/setup-your-own-private-github-server-using-gitlab-and-ubuntu-server-12-04-lts/

https://www.linux.com/learn/tutorials/824358-how-to-run-your-own-git-server</t>
<t tx="amd.20151124172242.1"># http://2014c2-mdenfu.rhcloud.com/c2g30/flag
# 直接送出 html 版本
@app.route("/drawflag")
def drawflag():
    '''
    原始程式來源: http://blog.roodo.com/esabear/archives/19215194.html
    改寫為 Brython 程式
    '''
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="300" height="200"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import document as doc
import math

# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
<t tx="amd.20151124205123.1"># 直接送出 html 版本
@app.route("/drawstar")
def drawstar():
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
# 導入 doc
from browser import document as doc
import math

# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 800 光點
ctx.setTransform(1, 0, 0, -1, 0, 800)

# 定義畫線函式
def draw_line(x1, y1, x2, y2, linethick = 3, color = "black"):
    ctx.beginPath()
    ctx.lineWidth = linethick
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()

# x, y 為中心,  r 為半徑, angle 旋轉角,  solid 空心或實心,  color 顏色
def star(x, y, r, angle=0, solid=False, color="#f00"):
    # 以 x, y 為圓心, 計算五個外點
    deg = math.pi/180
    # 圓心到水平線距離
    a = r*math.cos(72*deg)
    # a 頂點向右到內點距離
    b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg)
    # 利用畢氏定理求內點半徑
    rin = math.sqrt(a**2 + b**2)
    # 查驗 a, b 與 rin
    #print(a, b, rin)
    if(solid):
        ctx.beginPath()
    for i in range(5):
        xout = (x + r*math.sin((360/5)*deg*i+angle*deg))
        yout = (y + r*math.cos((360/5)*deg*i+angle*deg))
        # 外點增量 + 1
        xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg)
        yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg)
        xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg)
        yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg)
        # 查驗外點與內點座標
        #print(xout, yout, xin, yin)
        if(solid):
            # 填色
            if(i==0):
                ctx.moveTo(xout, yout)
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
            else:
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
        else:
            # 空心
            draw_line(xout, yout, xin, yin, color)
            # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關
            draw_line(xout2, yout2, xin, yin, color)
    if(solid):
        ctx.fillStyle = color
        ctx.fill()
star(600, 600, 100, 30, True, "#00f")
star(100, 100, 30, 0, True, "#f00")
#star(300, 300, 50, 0, False, "#000")
for i in range(5):
    for j in range(5):
        star(200+65*i, 200+65*j, 30, 0, False, "#000")
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring
</t>
<t tx="amd.20151124205805.1">/*==========================================================================*
  Filename: gearUtils-05.js
  By: Dr A.R.Collins

  JavaScript involute gear drawing utilities.
  Requires:
  'involuteBezCoeffs' can stand alone,
  'createGearTooth' and 'createIntGearTooth' generate draw commands for use
  in Cango graphics library but may be simply converted for use in SVG.

  Kindly give credit to Dr A.R.Collins &lt;http://www.arc.id.au/&gt;
  Report bugs to tony at arc.id.au

  Date   |Description                                                   |By
  --------------------------------------------------------------------------
  20Feb13 First public release                                           ARC
  21Feb13 Clarified variable names of start and end parameters           ARC
  06Mar13 Fixed Rf and filletAngle calculations                          ARC
  25Jun13 Code tidy for JSLint, use strict                               ARC
  16Mar15 Convert sweep direction of "A" commands for RHC coordinates    ARC
  
  source: http://www.arc.id.au/gearUtils-05.js
 *==========================================================================*/

  // exposed globals
  var involuteBezCoeffs, createGearTooth, createIntGearTooth;

(function()
{
  "use strict";
  /* ----------------------------------------------------------
   * involuteBezCoeffs
   *
   * JavaScript calculation of Bezier coefficients for
   * Higuchi et al. approximation to an involute.
   * ref: YNU Digital Eng Lab Memorandum 05-1
   *
   * Parameters:
   * module - sets the size of teeth (see gear design texts)
   * numTeeth - number of teeth on the gear
   * pressure angle - angle in degrees, usually 14.5 or 20
   * order - the order of the Bezier curve to be fitted [3, 4, 5, ..]
   * fstart - fraction of distance along tooth profile to start
   * fstop - fraction of distance along profile to stop
   *-----------------------------------------------------------*/
  involuteBezCoeffs = function(module, numTeeth, pressureAngle, order, fstart, fstop)
  {
    var PI = Math.PI,
        Rpitch = module*numTeeth/2,       // pitch circle radius
        phi = pressureAngle || 20,        // pressure angle
        Rb = Rpitch*Math.cos(phi*PI/180), // base circle radius
        Ra = Rpitch+module,               // addendum radius (outer radius)
        p = order || 3,                   // order of Bezier approximation
        ta = Math.sqrt(Ra*Ra-Rb*Rb)/Rb,   // involute angle at addendum
        stop = fstop || 1,
        start = 0.01,
        te, ts,
        bzCoeffs = [],
        i, bcoeff;

    function chebyExpnCoeffs(j, func)
    {
      var N = 50,      // a suitably large number  N&gt;&gt;p
          c = 0,
          k;

      for (k=1; k&lt;=N; k++)
      {
        c += func(Math.cos(PI*(k-0.5)/N)) * Math.cos(PI*j*(k-0.5)/N);
      }
      return 2*c/N;
    }

    function chebyPolyCoeffs(p, func)
    {
      var coeffs = [],
          fnCoeff = [],
          T = [[], []],
          i, j, k, pwr;

      // populate 1st 2 rows of T
      for (i=0; i&lt;p+1; i++)
      {
        T[0][i] = 0;
        T[1][i] = 0;
      }
      T[0][0] = 1;
      T[1][1] = 1;
      /* now generate the Chebyshev polynomial coefficient using
         formula T(k+1) = 2xT(k) - T(k-1) which yields
      T = [ [ 1,  0,  0,  0,  0,  0],    // T0(x) =  +1
            [ 0,  1,  0,  0,  0,  0],    // T1(x) =   0  +x
            [-1,  0,  2,  0,  0,  0],    // T2(x) =  -1  0  +2xx
            [ 0, -3,  0,  4,  0,  0],    // T3(x) =   0 -3x    0   +4xxx
            [ 1,  0, -8,  0,  8,  0],    // T4(x) =  +1  0  -8xx       0  +8xxxx
            [ 0,  5,  0,-20,  0, 16],    // T5(x) =   0  5x    0  -20xxx       0  +16xxxxx
            ...                     ];
      */
      for (k=1; k&lt;p+1; k++)
      {
        T[k+1] = [0];
        for (j=0; j&lt;T[k].length-1; j++)
        {
          T[k+1][j+1] = 2*T[k][j];
        }
        for (j=0; j&lt;T[k-1].length; j++)
        {
          T[k+1][j] -= T[k-1][j];
        }
      }
      // convert the chebyshev function series into a simple polynomial
      // and collect like terms, out T polynomial coefficients
      for (k=0; k&lt;=p; k++)
      {
        fnCoeff[k] = chebyExpnCoeffs(k, func);
        coeffs[k] = 0;
      }
      for (k=0; k&lt;=p; k++)
      {
        for (pwr=0; pwr&lt;=p; pwr++)    // loop thru powers of x
        {
          coeffs[pwr] += fnCoeff[k]*T[k][pwr];
        }
      }
      coeffs[0] -= chebyExpnCoeffs(0, func)/2;  // fix the 0th coeff

      return coeffs;
    }

    // Equation of involute using the Bezier parameter t as variable
    function involuteXbez(t)
    {
      // map t (0 &lt;= t &lt;= 1) onto x (where -1 &lt;= x &lt;= 1)
      var x = t*2-1;
      //map theta (where ts &lt;= theta &lt;= te) from x (-1 &lt;=x &lt;= 1)
      var theta = x*(te-ts)/2 + (ts + te)/2;
      return Rb*(Math.cos(theta)+theta*Math.sin(theta));
    }

    function involuteYbez(t)
    {
          // map t (0 &lt;= t &lt;= 1) onto x (where -1 &lt;= x &lt;= 1)
      var x = t*2-1,
          //map theta (where ts &lt;= theta &lt;= te) from x (-1 &lt;=x &lt;= 1)
          theta = x*(te-ts)/2 + (ts + te)/2;

      return Rb*(Math.sin(theta)-theta*Math.cos(theta));
    }

    function binom(n, k)
    {
      var coeff = 1,
          i;

      for (i = n-k+1; i &lt;= n; i++)
      {
        coeff *= i;
      }
      for (i = 1; i &lt;= k; i++)
      {
        coeff /= i;
      }

      return coeff;
    }

    function bezCoeff(i, func)
    {
      // generate the polynomial coeffs in one go
      var polyCoeffs = chebyPolyCoeffs(p, func),
          bc, j;

      for (bc=0, j=0; j&lt;=i; j++)
      {
        bc += binom(i,j)*polyCoeffs[j]/binom(p,j);
      }
      return bc;
    }

    if ((fstart !== undefined)&amp;&amp;(fstart&lt;stop))
    {
      start = fstart;
    }
    te = Math.sqrt(stop)*ta;          // involute angle, theta, at end of approx
    ts = Math.sqrt(start)*ta;         // involute angle, theta, at start of approx
    // calc Bezier coeffs
    for (i=0; i&lt;=p; i++)
    {
      bcoeff = {};
      bcoeff.x = bezCoeff(i, involuteXbez);
      bcoeff.y = bezCoeff(i, involuteYbez);
      bzCoeffs.push(bcoeff);
    }

    return bzCoeffs;
  };

  function rotate(pt, rads)  // rotate pt by rads radians about origin
  {
    var sinA = Math.sin(rads),
        cosA = Math.cos(rads);

    return {x: pt.x*cosA - pt.y*sinA,
            y: pt.x*sinA + pt.y*cosA};
  }

  function toCartesian(radius, angle)   // convert polar coords to cartesian
  {
    return {x: radius*Math.cos(angle),
            y: radius*Math.sin(angle)};
  }

  function genInvolutePolar(Rb, R)  // Rb = base circle radius
  {
    // returns the involute angle as function of radius R.
    return (Math.sqrt(R*R - Rb*Rb)/Rb) - Math.acos(Rb/R);
  }

  /*----------------------------------------------------------
    createGearTooth
    Create an array of drawing commands and their coordinates
    to draw a single spur gear tooth based on a circle
    involute using the metric gear standards.

    Requires Cango graphics library Rev 2.08 or later
   ----------------------------------------------------------*/
  createGearTooth = function(module, teeth, pressureAngle)
  {
    // ****** external gear specifications
    var m = module,                                     // Module = mm of pitch diameter per tooth
        Z = teeth,                                      // Number of teeth
        phi = pressureAngle || 20,                      // pressure angle (degrees)
        addendum = m,                                   // distance from pitch circle to tip circle
        dedendum = 1.25*m,                              // pitch circle to root, sets clearance
        clearance = dedendum - addendum,
        // Calculate radii
        Rpitch = Z*m/2,                                 // pitch circle radius
        Rb = Rpitch*Math.cos(phi*Math.PI/180),          // base circle radius
        Ra = Rpitch + addendum,                         // tip (addendum) circle radius
        Rroot = Rpitch - dedendum,                      // root circle radius
        fRad = 1.5*clearance,                           // fillet radius, max 1.5*clearance
        Rf,                                             // radius at top of fillet
        // ****** calculate angles (all in radians)
        pitchAngle = 2*Math.PI/Z,                       // angle subtended by whole tooth (rads)
        baseToPitchAngle = genInvolutePolar(Rb, Rpitch),
        pitchToFilletAngle = baseToPitchAngle,          // profile starts at base circle
        filletAngle = Math.atan(fRad/(fRad+Rroot)),     // radians
        fe, fs, fm,
        dedBz, addBz, inv, invR,
        fillet, filletR, filletNext,
        rootR, rootNext,
        pt, i, data;

    Rf = Math.sqrt((Rroot+fRad)*(Rroot+fRad)-(fRad*fRad)); // radius at top of fillet
    if (Rb &lt; Rf)
    {
      Rf = Rroot+clearance;
    }
    if (Rf &gt; Rb)                   // start profile at top of fillet (if its greater)
    {
      pitchToFilletAngle -= genInvolutePolar(Rb, Rf);
    }
    // ****** generate Higuchi involute approximation
    fe = 1;                    // fraction of profile length at end of approx
    fs = 0.01;                 // fraction of length offset from base to avoid singularity
    if (Rf &gt; Rb)
    {
      fs = (Rf*Rf-Rb*Rb)/(Ra*Ra-Rb*Rb);  // offset start to top of fillet
    }
    // approximate in 2 sections, split 25% along the involute
    fm = fs+(fe-fs)/4;         // fraction of length at junction (25% along profile)
    dedBz = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
    addBz = involuteBezCoeffs(m, Z, phi, 3, fm, fe);
    // join the 2 sets of coeffs (skip duplicate mid point)
    inv = dedBz.concat(addBz.slice(1));
    //create the back profile of tooth (mirror image)
    invR = [];                // involute profile along back of tooth
    for (i=0; i&lt;inv.length; i++)
    {
      // rotate all points to put pitch point at y = 0
      pt = rotate(inv[i], -baseToPitchAngle-pitchAngle/4);
      inv[i] = pt;
      // generate the back of tooth profile nodes, mirror coords in X axis
      invR[i] = {x:pt.x, y:-pt.y};
    }
    // ****** calculate section junction points R=back of tooth, Next=front of next tooth)
    fillet = toCartesian(Rf, -pitchAngle/4-pitchToFilletAngle); // top of fillet
    filletR = {x:fillet.x, y:-fillet.y};   // flip to make same point on back of tooth
    rootR = toCartesian(Rroot, pitchAngle/4+pitchToFilletAngle+filletAngle);
    rootNext = toCartesian(Rroot, 3*pitchAngle/4-pitchToFilletAngle-filletAngle);
    filletNext = rotate(fillet, pitchAngle);  // top of fillet, front of next tooth
    // ****** create the drawing command data array for the tooth
    data = [];
    data.push("M", fillet.x, fillet.y);           // start at top of fillet
    if (Rf &lt; Rb)
    {
      data.push("L", inv[0].x, inv[0].y);         // line from fillet up to base circle
    }
    data.push("C", inv[1].x, inv[1].y, inv[2].x, inv[2].y, inv[3].x, inv[3].y,
                   inv[4].x, inv[4].y, inv[5].x, inv[5].y, inv[6].x, inv[6].y);
    data.push("A", Ra, Ra, 0, 0, 1, invR[6].x, invR[6].y); // arc across addendum circle, sweep 1 for RHC, 0 for SVG
    data.push("C", invR[5].x, invR[5].y, invR[4].x, invR[4].y, invR[3].x, invR[3].y,
                   invR[2].x, invR[2].y, invR[1].x, invR[1].y, invR[0].x, invR[0].y);
    if (Rf &lt; Rb)
    {
      data.push("L", filletR.x, filletR.y);       // line down to top of fillet
    }
    if (rootNext.y &gt; rootR.y)    // is there a section of root circle between fillets?
    {
      data.push("A", fRad, fRad, 0, 0, 0, rootR.x, rootR.y); // back fillet, sweep 0 for RHC, 1 for SVG
      data.push("A", Rroot, Rroot, 0, 0, 1, rootNext.x, rootNext.y); // root circle arc, sweep 1 for RHC, 0 for SVG
    }
    data.push("A", fRad, fRad, 0, 0, 0, filletNext.x, filletNext.y); // sweep 0 for RHC, 1 for SVG

    return data;  // return an array of Cango (SVG) format draw commands
  };

  /*----------------------------------------------------------
    createIntGearTooth
    Create an array of drawing commands and their coordinates
    to draw a single internal (ring)gear tooth based on a
    circle involute using the metric gear standards.

    Requires Cango graphics library Rev 2.08 or later
   ----------------------------------------------------------*/
  createIntGearTooth = function(module, teeth, pressureAngle)
  {
    // ****** gear specifications
    var m = module,                               // Module = mm of pitch diameter per tooth
        Z = teeth,                                // Number of teeth
        phi = pressureAngle || 20,                // pressure angle (degrees)
        addendum = 0.6*m,                         // pitch circle to tip circle (ref G.M.Maitra)
        dedendum = 1.25*m,                        // pitch circle to root radius, sets clearance
        // Calculate radii
        Rpitch = Z*m/2,                           // pitch radius
        Rb = Rpitch*Math.cos(phi*Math.PI/180),    // base radius
        Ra = Rpitch - addendum,                   // addendum radius
        Rroot = Rpitch + dedendum,                // root radius
        clearance = 0.25*m,                       // gear dedendum - pinion addendum
        Rf = Rroot - clearance,                   // radius of top of fillet (end of profile)
        fRad = 1.5*clearance,                     // fillet radius, 1 .. 1.5*clearance
        pitchAngle,                               // angle between teeth (rads)
        baseToPitchAngle,
        tipToPitchAngle,
        pitchToFilletAngle,
        filletAngle,
        fe, fs, fm,
        addBz, dedBz,
        inv, invR,
        pt, i, data,
        fillet, filletNext,
        tip, tipR,
        rootR, rootNext;

    // ****** calculate subtended angles
    pitchAngle = 2*Math.PI/Z;                       // angle between teeth (rads)
    baseToPitchAngle = genInvolutePolar(Rb, Rpitch);
    tipToPitchAngle = baseToPitchAngle;             // profile starts from base circle
    if (Ra &gt; Rb)
    {
      tipToPitchAngle -= genInvolutePolar(Rb, Ra);  // start profile from addendum
    }
    pitchToFilletAngle = genInvolutePolar(Rb, Rf) - baseToPitchAngle;
    filletAngle = 1.414*clearance/Rf;               // to make fillet tangential to root
    // ****** generate Higuchi involute approximation
    fe = 1;                   // fraction of involute length at end of approx (fillet circle)
    fs = 0.01;                 // fraction of length offset from base to avoid singularity
    if (Ra &gt; Rb)
    {
      fs = (Ra*Ra-Rb*Rb)/(Rf*Rf-Rb*Rb);    // start profile from addendum (tip circle)
    }
    // approximate in 2 sections, split 25% along the profile
    fm = fs+(fe-fs)/4;        //
    addBz = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
    dedBz = involuteBezCoeffs(m, Z, phi, 3, fm, fe);
    // join the 2 sets of coeffs (skip duplicate mid point)
    invR = addBz.concat(dedBz.slice(1));
    //create the front profile of tooth (mirror image)
    inv = [];         // back involute profile
    for (i=0; i&lt;invR.length; i++)
    {
      // rotate involute to put center of tooth at y = 0
      pt = rotate(invR[i], pitchAngle/4-baseToPitchAngle);
      invR[i] = pt;
      // generate the back of tooth profile, flip Y coords
      inv[i] = {x:pt.x, y:-pt.y};
    }
    // ****** calculate coords of section junctions
    fillet = {x:inv[6].x, y:inv[6].y};    // top of fillet, front of tooth
    tip = toCartesian(Ra, -pitchAngle/4+tipToPitchAngle);  // tip, front of tooth
    tipR = {x:tip.x, y:-tip.y};  // addendum, back of tooth
    rootR = toCartesian(Rroot, pitchAngle/4+pitchToFilletAngle+filletAngle);
    rootNext = toCartesian(Rroot, 3*pitchAngle/4-pitchToFilletAngle-filletAngle);
    filletNext = rotate(fillet, pitchAngle);  // top of fillet, front of next tooth
    // ****** create the drawing command data array for the tooth
    data = [];
    data.push("M", inv[6].x, inv[6].y);  // start at top of front profile
    data.push("C", inv[5].x, inv[5].y, inv[4].x, inv[4].y, inv[3].x, inv[3].y,
                   inv[2].x, inv[2].y, inv[1].x, inv[1].y, inv[0].x, inv[0].y);
    if (Ra &lt; Rb)
    {
      data.push("L", tip.x, tip.y);  // line from end of involute to addendum (tip)
    }
    data.push("A", Ra, Ra, 0, 0, 1, tipR.x, tipR.y); // arc across tip circle, sweep 1 for RHC, 0 for SVG
    if (Ra &lt; Rb)
    {
      data.push("L", invR[0].x, invR[0].y);  // line from addendum to start of involute
    }
    data.push("C", invR[1].x, invR[1].y, invR[2].x, invR[2].y, invR[3].x, invR[3].y,
                   invR[4].x, invR[4].y, invR[5].x, invR[5].y, invR[6].x, invR[6].y);
    if (rootR.y &lt; rootNext.y)    // there is a section of root circle between fillets
    {
      data.push("A", fRad, fRad, 0, 0, 1, rootR.x, rootR.y); // fillet on back of tooth, sweep 1 for RHC, 0 for SVG
      data.push("A", Rroot, Rroot, 0, 0, 1, rootNext.x, rootNext.y); // root circle arc, sweep 1 for RHC, 0 for SVG
    }
    data.push("A", fRad, fRad, 0, 0, 1, filletNext.x, filletNext.y); // fillet on next, sweep 1 for RHC, 0 for SVG 

    return data;  // return an array of Cango (SVG) format draw commands
  };

}());</t>
<t tx="amd.20151124210158.1"># 直接送出 html 版本
@app.route("/drawcango")
def drawcango():
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Cango-7v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
import math

cango = JSConstructor(window.Cango)
cgo = cango("plotarea")
cgo.setGridboxRHC()
cgo.setWorldCoords(-1, -25, 2, 50) 
cgo.drawText("使用 Cango 繪圖程式庫!", 0, 0, {"fontSize":60, "fontWeight": 1200, "lorg":5 })

# Cango2D example
cango2d = JSConstructor(window.Cango2D)
tweener = JSConstructor(window.Tweener)
g = cango2d("plotarea")
g.setWorldCoords(-10, -10, 20)
hello = g.drawText("加油!加油!", 0, 0, {
"fillColor":"blue",
"fontSize":16,
"lorg":5 })
sclTwn = tweener([1, 2, 1], 1000, 5000, 'loopAll')
rotTwn = tweener([0, 360, -360], 1000, 5000, 'loopAll')
hello.transform.scale(sclTwn)
hello.transform.rotate(rotTwn)
g.animate(hello)
g.playAnimation()
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring
</t>
<t tx="amd.20151124215720.1"># 直接送出 html 版本
@app.route("/drag")
def drag():
    outstring = '''
&lt;!DOCTYPE html&gt; 
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;script type="text/javascript" src="/static/Cango2D-6v13.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/Brython3.2.3-20151122-082712/brython.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="brython({debug:1, cache:'version'})"&gt;
&lt;canvas id="plotarea" width="800" height="800"&gt;&lt;/canvas&gt;
&lt;script type="text/python"&gt;
from browser import window
from javascript import JSConstructor
  
cango = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
cgo = cango("plotarea")
x1, y1 = 40, 20
cx1, cy1 = 90, 120
x2, y2 = 120, 100
cx2, cy2 = 130, 20
cx3, cy3 = 150, 120
x3, y3 = 180, 60

def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()
 
def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()
 
def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()
 
def drawCurve():
    # curve change shape so it must be re-draw each time
    # draw a quadratic bezier from x1,y2 to x2,y2
    qbez = obj2d(['M', x1, y1, 'Q', cx1, cy1, x2, y2], "PATH",  {
          "strokeColor":'blue'})
    cbez = obj2d(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], "PATH",  {
          "strokeColor":'green'})
    # show lines to control point
    L1 = obj2d(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})  # semi-transparent gray
    L2 = obj2d(['M', x2, y2, 'L', cx2, cy2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    L3 = obj2d(['M', x3, y3, 'L', cx3, cy3], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    # draw draggable control points
    c1.transform.reset()
    c1.transform.translate(cx1, cy1)
    c2.transform.reset()
    c2.transform.translate(cx2, cy2)
    c3.transform.reset()
    c3.transform.translate(cx3, cy3)
    grp = cgo.createGroup2D(qbez, cbez, L1, L2, L3, c1, c2, c3)
    cgo.renderFrame(grp)
 
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(0, 0, 200)
 
# draggable control points
c1 = obj2d(shapedefs.circle(4), "SHAPE", {"fillColor":'red'})
c1.enableDrag(None, dragC1, None)
c2 = c1.dup()
c2.enableDrag(None, dragC2, None)
c3 = c1.dup()
c3.enableDrag(None, dragC3, None)
drawCurve();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
    return outstring</t>
</tnodes>
</leo_file>
